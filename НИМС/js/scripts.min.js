/*Copyright 2018 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const showNotification = true;
    const notificationTimeout = 2000;
    
    exports.onCallStart = () => {
        if (!showNotification) return;
        const notificationBox = clearEl(getEl('debugNotification'));
        removeClass(notificationBox, 'hidden');
        removeClass(notificationBox, 'operationOK');
        removeClass(notificationBox, 'operationFail');
        addEl(notificationBox, makeText(L10n.get('constant', 'saving')));
    };
    
    exports.onCallFinished = (err) => {
        if (!showNotification) return;
        if(err) {
            onCallFail();
        } else {
            onCallSuccess();
        }
    };

    function onCallSuccess(){
        const notificationBox = getEl('debugNotification');
        addClass(notificationBox, 'operationOK');
        addEl(clearEl(notificationBox), makeText(L10n.get('constant', 'saving-success')));
        setTimeout(() => {
            addClass(notificationBox, 'hidden');
        }, notificationTimeout);
    }

    function onCallFail(){
        const notificationBox = getEl('debugNotification');
        addClass(notificationBox, 'operationFail');
        addEl(clearEl(notificationBox), makeText(L10n.get('constant', 'saving-fail')));
        setTimeout(() => {
            addClass(notificationBox, 'hidden');
        }, notificationTimeout);
    }
    
    
})(this.CallNotificator = {});

/*Copyright 2015 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

/*global
 Utils, Database, Migrator
 */

'use strict';

/* eslint-disable func-names */

function makeLocalDBMS(fullVersion) {
//    if(!fullVersion){
//        function LocalDBMS(){
//        };
//        return LocalDBMS;
//    }
    const listeners = {};

    function addListener(eventName, callback) {
        listeners[eventName] = listeners[eventName] || [];
        listeners[eventName].push(callback);
    }

    const opts = {
        Migrator,
        CommonUtils,
        CU: CommonUtils,
        ProjectUtils,
        PU: ProjectUtils,
        Precondition,
        PC: Precondition,
        EventEmitter,
        R,
        Ajv,
        Schema,
        Errors,
        addListener,
        Constants,
        dbmsUtils: {},
        dateFormat,
    };

    function LocalDBMS() {
        this._init(listeners);
    }

    LocalDBMS.prototype.getSettings = function () {
        'use strict';

        return this.database.Settings;
    };

    const funcList = {};
    const func = R.curry((name) => {
        const before = R.keys(LocalDBMS.prototype);
        window[name](LocalDBMS, opts);
        const after = R.keys(LocalDBMS.prototype);
        const diff = R.difference(after, before);
        //        console.log(`${name} ${diff}`);
        funcList[name] = R.zipObj(diff, R.repeat(true, diff.length));
    });

    ['baseAPI',
        'consistencyCheckAPI',
        'statisticsAPI',
        'profilesAPI',
        'profileBindingAPI',

        'profileViewAPI',

        'groupsAPI',
        'groupSchemaAPI',
        'relationsAPI',
        'briefingExportAPI',

        'profileConfigurerAPI',
        'entityAPI',
        'storyBaseAPI',
        'storyEventsAPI',
        'storyCharactersAPI',

        'storyViewAPI',
        'storyAdaptationsAPI',
        'accessManagerAPI',
        'textSearchAPI',
        'gearsAPI',
        'slidersAPI',
        'logAPI'].map(func);

    Logger.attachLogCalls(LocalDBMS, R, false);

    const baseAPIList = R.keys(R.mergeAll(R.values(funcList)));
    const loggerAPIList = R.difference(R.keys(R.mergeAll(R.values(Logger.apiInfo))), Logger.offlineIgnoreList);

    const loggerDiff = R.symmetricDifference(loggerAPIList, baseAPIList);
    if (loggerDiff.length > 0) {
        console.error(`Logger diff: ${loggerDiff}`);
        console.error(`Logged but not in base: ${R.difference(loggerAPIList, baseAPIList)}`);
        console.error(`In base but not logged: ${R.difference(baseAPIList, loggerAPIList)}`);
        throw new Error('API processors are inconsistent');
    }

    return LocalDBMS;
}

function makeLocalDBMSWrapper(dbms) {

    function LocalDBMSWrapper(dbms) {
        this.dbms = dbms;
        this.clearSettings();
    }
    
    Object.keys(dbms.__proto__).forEach((name) => {
        LocalDBMSWrapper.prototype[name] = function () {
            if (CommonUtils.startsWith(name, 'get') || CommonUtils.startsWith(name, 'is') || R.equals(name, 'log')) {
                this.dbms[name].apply(this.dbms, arguments);
            } else {
                const callback = arguments[arguments.length - 1];
                const arr = [];
                for (let i = 0; i < arguments.length - 1; i++) {
                    arr.push(arguments[i]);
                }
                
                CallNotificator.onCallStart();
                
                arr.push(function(err) {
                    CallNotificator.onCallFinished(err);
                    callback(err);
                });
                this.dbms[name].apply(this.dbms, arr);
            }
        };
    });
    
    Promisificator.promisify(dbms, LocalDBMSWrapper);

    LocalDBMSWrapper.prototype.clearSettings = function () {
        this.Settings = {
            BriefingPreview: {},
            Stories: {},
            ProfileEditor: {}
        };
    };

    LocalDBMSWrapper.prototype.getSettings = function () {
        return this.Settings;
    };
    return new LocalDBMSWrapper(dbms);
}
/*Copyright 2018 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    exports.promisify = (src, dst) => {
        Object.keys(src.__proto__).forEach((name) => {
            dst.prototype[name + 'Pm'] = function () {
                if (CommonUtils.startsWith(name, 'get') || CommonUtils.startsWith(name, 'is') || R.equals(name, 'log')) {
                    const arr = [];
                    for (let i = 0; i < arguments.length; i++) {
                        arr.push(arguments[i]);
                    }
                    
                    return new Promise(function(resolve, reject) {
                        arr.push(function(err, value) {
                            if(err) {reject(err); return;}
                            resolve(value);
                        });
                        this.dbms[name].apply(this.dbms, arr);
                    }.bind(this));
                } else {
                    const arr = [];
                    for (let i = 0; i < arguments.length; i++) {
                        arr.push(arguments[i]);
                    }
                    
                    CallNotificator.onCallStart();
                    
                    return new Promise(function(resolve, reject) {
                        arr.push(function(err, value) {
                            CallNotificator.onCallFinished(err);
                            
                            if(err) {reject(err); return;}
                            resolve();
                        });
                        this.dbms[name].apply(this.dbms, arr);
                    }.bind(this));
                }
            }
        });
    }
    
    
})(this.Promisificator = {});

/*Copyright 2015 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

/*global
 Utils, Database
 */

'use strict';

/* eslint-disable func-names,prefer-rest-params */


function makeRemoteDBMS(LocalDBMS) {
    const showNotification = true;
    const notificationTimeout = 2000;
    //const notificationTimeout = 10000;
    const url = '/';

    function RemoteDBMS() {
        this.clearSettings();
    }

    RemoteDBMS._simpleGet = function (name, params, callback) {
        let paramStr = '';
        if (params) {
            paramStr = `?params=${encodeURIComponent(JSON.stringify(params))}`;
        }

        const request = $.ajax({
            url: url + name + paramStr,
            dataType: 'text',
            method: 'GET',
            contentType: 'application/json;charset=utf-8',
            cache: false,
            timeout: Constants.httpTimeout,
        });

        request.done((data) => {
            callback(null, JSON.parse(data));
        });

        request.fail((errorInfo, textStatus, errorThrown) => {
            try {
                callback(JSON.parse(errorInfo.responseText));
            } catch (err) {
                callback(errorInfo.responseText || textStatus || 'error');
            }
        });
    };

    RemoteDBMS._simplePut = function (name, data, callback) {
        const request = $.ajax({
            url: url + name,
            dataType: 'text',
            method: 'PUT',
            contentType: 'application/json;charset=utf-8',
            data: JSON.stringify(data),
            timeout: Constants.httpTimeout
        });
        
        CallNotificator.onCallStart();

        request.done((data2) => {
            CallNotificator.onCallFinished();
            if (callback) callback();
        });

        request.fail((errorInfo, textStatus, errorThrown) => {
            CallNotificator.onCallFinished(errorInfo);
            try {
                callback(JSON.parse(errorInfo.responseText));
            } catch (err) {
                callback(errorInfo.responseText || textStatus || 'error');
            }
        });
    };


    Object.keys(LocalDBMS.prototype).forEach((name) => {
        RemoteDBMS.prototype[name] = function () {
            const arr = [];
            for (let i = 0; i < arguments.length - 1; i++) {
                arr.push(arguments[i]);
            }
            //            if(CommonUtils.startsWith(name, "_")){
            //                // do nothing for inner functions
            //            } else
            if (CommonUtils.startsWith(name, 'get') || CommonUtils.startsWith(name, 'is')) {
                RemoteDBMS._simpleGet(name, arr, arguments[arguments.length - 1]);
            } else {
                RemoteDBMS._simplePut(name, arr, arguments[arguments.length - 1]);
            }
        };
    });
    
    // promisification
    Object.keys(LocalDBMS.prototype).forEach((name) => {
        RemoteDBMS.prototype[name + 'Pm'] = function () {
            const arr = [];
            for (let i = 0; i < arguments.length; i++) {
                arr.push(arguments[i]);
            }
            //            if(CommonUtils.startsWith(name, "_")){
            //                // do nothing for inner functions
            //            } else
            return new Promise(function(resolve, reject) {
                if (CommonUtils.startsWith(name, 'get') || CommonUtils.startsWith(name, 'is')) {
                    RemoteDBMS._simpleGet(name, arr, function(err, value) {
                        if(err) {reject(err); return;}
                        resolve(value);
                    });
                } else {
                    RemoteDBMS._simplePut(name, arr, function(err, value) {
                        if(err) {reject(err); return;}
                        resolve();
                    });
                }
            }.bind(this));
        };
    });

    RemoteDBMS.prototype.clearSettings = function () {
        this.Settings = {
            BriefingPreview: {},
            Stories: {},
            ProfileEditor: {}
        };
    };

    RemoteDBMS.prototype.getSettings = function () {
        return this.Settings;
    };
    return RemoteDBMS;
}

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    exports.makeNewBase = (callback) => () => {
        Utils.confirm(getL10n('utils-new-base-warning'), () => {
            DBMS.setDatabase(CommonUtils.clone(EmptyBase.data), callback);
//            TestUtils.addGroupTestingData();
        });
    };

    exports.openHelp = () => {
        window.open('extras/doc/nims.html');
    };

    exports.readSingleFile = (callback) => (evt) => {
        // Retrieve the first (and only!) File from the FileList object
        const f = evt.target.files[0];

        if (f) {
            const r = new FileReader();
            r.onload = (e) => {
                const contents = e.target.result;
                try {
                    const database = JSON.parse(contents);
                    DBMS.setDatabase(database, callback);
                } catch (err) {
                    callback(err);
                }
            };
            r.readAsText(f);
        } else {
            Utils.alert(getL10n('utils-base-file-loading-error'));
        }
    };

    exports.saveFile = () => {
        DBMS.getDatabase((err, database) => {
            if (err) { Utils.handleError(err); return; }
            exports.json2File(database, exports.makeFileName(`${BASE_FILE_NAME}_${database.Meta.name}`, 'json', new Date(database.Meta.saveTime)));
        });
    };
    
    exports.makeFileName = (root, extension, date) => {
        date = date || new Date();
        const timeStr = date.format('dd-mmm-yyyy_HH-MM-ss');
        const fileName = `${root}_${timeStr}`;
        return `${CommonUtils.sanitizeStr2FileName(fileName)}.${extension}`;
    };

    exports.json2File = (str, fileName) => {
        exports.str2File(JSON.stringify(str, null, '  '), fileName);
    };

    exports.str2File = (str, fileName) => {
        const blob = new Blob([str], {
            type: 'text/plain;charset=utf-8'
        });
        saveAs(blob, fileName);
    };

    function preprocessCsvStr(str) {
        if (!(typeof str === 'string' || str instanceof String)) {
            return str;
        }
        let result = str.replace(/"/g, '""');
        if (result.search(/("|,|\n)/g) >= 0) {
            result = `"${result}"`;
        }
        return result;
    }

    exports.arr2d2Csv = (arr, fileName) => {
        const csv = `\ufeff${arr.map(dataArray => dataArray.map(preprocessCsvStr).join(';')).join('\n')}`;

        const out = new Blob([csv], {
            type: 'text/csv;charset=utf-8;'
        });
        saveAs(out, exports.makeFileName(fileName, 'csv'));
    };
})(this.FileUtils = {});

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

/* eslint-disable no-var,vars-on-top */

((exports, Dictionaries) => {
    const state = {};

    state.initialized = false;
    state.l10nDelegates = [];
    state.dictionaries = {};
    state.lang = defaultLang;
    state.foundStatistics = {};
    state.notFoundStatistics = {};

    exports.init = () => {
        if (state.initialized) {
            return;
        }
        //        console.log(navigator.language);

        state.dictionaries = R.map(processDictionary, Dictionaries);
        
        dictIterator(checkDictionaryCompleteness);
        dictIterator(checkDictionaryInsertCount);
        showDuplicates();

        //    var lang = (navigator.languages ? navigator.languages[0] : navigator.browserLanguage).split('-')[0];
        //    var lang = 'ru';
        //        var lang = defaultLang;
        //        console.log(lang);

        if (state.dictionaries[defaultLang]) {
            state.dict = state.dictionaries[defaultLang];
        } else {
            state.dict = state.dictionaries.en;
        }
        setHtmlLang(defaultLang);
        exports.onL10nChange(exports.localizeStatic);
        state.initialized = true;
    };
    
    function dictIterator(callback){
        const dictNames = R.keys(state.dictionaries);
        if(dictNames.length < 2) {
            return;
        }
        const base = R.head(dictNames);
        R.tail(dictNames).forEach( dictName => {
            callback(base, dictName);
        });
    }
    
    function checkDictionaryCompleteness(base, dictName){
        const baseToDict = R.difference(R.keys(state.dictionaries[base]), R.keys(state.dictionaries[dictName]));
        if(baseToDict.length > 0){
            console.log(`L10N: ${base} to ${dictName} difference is not empty `, baseToDict);
        } else {
            console.log(`L10N: ${base} to ${dictName} difference is empty (OK)`);
        }
        const dictToBase = R.difference(R.keys(state.dictionaries[dictName]), R.keys(state.dictionaries[base]));
        if(dictToBase.length > 0){
            console.log(`L10N: ${dictName} to ${base} difference is not empty `, dictToBase);
        } else {
            console.log(`L10N: ${dictName} to ${base} difference is empty (OK)`);
        }
    }
    
    function checkDictionaryInsertCount(base, dictName){
        const baseInst = state.dictionaries[base];
        const dictInst = state.dictionaries[dictName];
        const intersection = R.intersection(R.keys(baseInst), R.keys(state.dictionaries[dictName]));
        const notEqual = intersection.filter(key => {
            return CommonUtils.strFormatInsertsCount(baseInst[key]) !== CommonUtils.strFormatInsertsCount(dictInst[key])
        });
        if(notEqual.length > 0) {
            console.log(`L10N: insert counts for ${dictName} and ${base} are not equal`, notEqual);
        } else {
            console.log(`L10N: insert counts for ${dictName} and ${base} are equal (OK)`);
        }
    }
    
    function showDuplicates(){
        R.keys(state.dictionaries).forEach(key => {
            const map = R.filter(arr => arr.length > 1, R.invert(state.dictionaries[key]));
            console.log(`L10N: Duplicates ${key} `, map);
        });
    }

    var processDictionary = (dictionary) => {
        const processedDictionary = {};
        R.toPairs(dictionary).forEach(([sectionName, section]) => {
            R.toPairs(section).forEach(([key, value]) => {
                processedDictionary[`${sectionName}-${key}`] = value;
            });
        });
        //        for (const sectionName in dictionary) {
        //            for (const name in dictionary[sectionName]) {
        //                processedDictionary[`${sectionName}-${name}`] = dictionary[sectionName][name];
        //            }
        //        }
        return processedDictionary;
    };

    var setHtmlLang = lang => setAttr(document.getElementsByTagName('html')[0], 'lang', lang);
    
    exports.getLocale = () => state.lang;

    exports.toggleL10n = () => {
        if (state.lang === 'ru') {
            state.dict = state.dictionaries.en;
            state.lang = 'en';
        } else {
            state.dict = state.dictionaries.ru;
            state.lang = 'ru';
        }
        state.foundStatistics.clear();
        state.notFoundStatistics.clear();
        
        setHtmlLang(state.lang);
        state.l10nDelegates.forEach((delegate) => {
            delegate();
        });
        
    };

    exports.getLang = () => state.lang.toLowerCase();

    exports.format = R.curry((namespace, name, args) => strFormat(exports.get(namespace, name), args));

    exports.get = R.curry((namespace, name) => L10n.getValue(`${namespace}-${name}`));

    exports.getValue = (name) => {
        const value = state.dict[name];
        if (value === undefined) {
            console.log(`Value is not found: ${name}`);
            state.notFoundStatistics[name] = (state.notFoundStatistics[name] || 0) + 1;
        } else {
            state.foundStatistics[name] = (state.foundStatistics[name] || 0) + 1;
        }
        return value || `${name}:RA RA-AH-AH-AH ROMA ROMA-MA GAGA OH LA-LA`;
    };
    
    exports.hasValue = (name) => {
        const value = state.dict[name];
        return value !== undefined;
    };

    exports.onL10nChange = (delegate) => {
        state.l10nDelegates.push(delegate);
    };

    exports.localizeStatic = (el) => {
        el = el || document;
        nl2array(qees(el, '[l10n-id]')).map(el2 =>
            addEl(clearEl(el2), makeText(exports.getValue(getAttr(el2, 'l10n-id')))));
        nl2array(qees(el, '[l10n-placeholder-id]')).map(el2 =>
            setAttr(el2, 'placeholder', exports.getValue(getAttr(el2, 'l10n-placeholder-id'))));
        nl2array(qees(el, '[l10n-title]')).map(el2 =>
            setAttr(el2, 'title', exports.getValue(getAttr(el2, 'l10n-title'))));
    };
    
    exports.getFoundStatistics = () => R.clone(state.foundStatistics);
    exports.getNotFoundStatistics = () => R.clone(state.notFoundStatistics);
    
    exports.getNotUsedByStatistics = () => R.difference(R.keys(state.dict), R.keys(state.foundStatistics));
    
})(this.L10n = {}, Dictionaries);

/*Copyright 2018 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const indexedDB     = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
    const IDBTransaction  = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
    const baseName      = "filesBase";
    const storeName     = "filesStore";
    
// // This works on all devices/browsers, and uses IndexedDBShim as a final fallback 
//    var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
//
//    // Open (or create) the database
//    var open = indexedDB.open("MyDatabase", 1);
//
//    // Create the schema
//    open.onupgradeneeded = function() {
//        var db = open.result;
//        var store = db.createObjectStore("MyObjectStore", {keyPath: "id"});
//        var index = store.createIndex("NameIndex", ["name.last", "name.first"]);
//    };
//
//    open.onsuccess = function() {
//        // Start a new transaction
//        var db = open.result;
//        var tx = db.transaction("MyObjectStore", "readwrite");
//        var store = tx.objectStore("MyObjectStore");
//        var index = store.index("NameIndex");
//
//        // Add some data
//        store.put({id: 12345, name: {first: "John", last: "Doe"}, age: 42});
//        store.put({id: 67890, name: {first: "Bob", last: "Smith"}, age: 35});
//        
//        // Query the data
//        var getJohn = store.get(12345);
//        var getBob = index.get(["Smith", "Bob"]);
//
//        getJohn.onsuccess = function() {
//            console.log(getJohn.result.name.first);  // => "John"
//        };
//
//        getBob.onsuccess = function() {
//            console.log(getBob.result.name.first);   // => "Bob"
//        };
//
//        // Close the db when the transaction is done
//        tx.oncomplete = function() {
//            db.close();
//        };
//    }
    
    exports.test = () => {
//        console.log('2323223');
//        exports.put('base1', {
//            'sd':12,
//        }, logerr2);
//        exports.put('base2', {
//            'ssdsdd':1654654,
//        }, logerr2);
//        exports.get('base1', (err, base) => {
//            if(err) {console.log(err); return;}
//            console.log(base);
//        });
//        exports.get('base3', (err, base) => {
//            if(err) {console.log(err); return;}
//            console.log(base);
//        });
    };

    function logerr(err){
        console.log(err);
    }
    
    var logerr2 = (err) => {
        if(err) {console.log(err); return;}
    };
    
    function connectDB(callback){
        var request = indexedDB.open(baseName, 1);
        request.onerror = callback;
        request.onsuccess = function(){
            callback(null, request.result);
        }
        request.onupgradeneeded = function(e){
            e.currentTarget.result.createObjectStore(storeName, { keyPath: "id" });
            connectDB(callback);
        }
    }
    
    exports.get = (id) => {
        return new Promise(function(resolve, reject) {
            connectDB(function(err, db){
                if(err) {reject(err); return;}
                var request = db.transaction([storeName], "readonly").objectStore(storeName).get(id);
                request.onerror = reject;
                request.onsuccess = function(){
                    resolve(request.result ? request.result : null);
                }
            });
        });
    }
    
    exports.put = (id, obj) => {
        return new Promise(function(resolve, reject) {
            connectDB(function(err, db){
                if(err) {reject(err); return;}
                var request = db.transaction([storeName], "readwrite").objectStore(storeName).put({id, obj});
                request.onerror = reject;
                request.onsuccess = function(){
                    resolve(request.result);
                }
            });
        });
    }
})(this.LocalBaseAPI = {});
/*Copyright 2018 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    exports.runTests = () => {
        queryEl('body').style.overflow = 'auto';
        window.RunTests();
    };

    exports.showConsistencyCheckAlert = (checkRes) => {
        if (checkRes === undefined || checkRes.errors.length === 0) {
            Utils.alert(getL10n('overview-consistency-is-ok'));
        } else {
            Utils.alert(getL10n('overview-consistency-problem-detected'));
        }
    };

    exports.clickThroughtHeaders = () => {
        let tabs = queryEls('#navigation .navigation-button');

        let index = 0;
        let subTabsNum = 0;
        function runClicker() {
            if (index <= tabs.length - 1) {
                tabs[index].click();
                if (subTabsNum === 0) {
                    const subTabs = queryEls('#contentArea .navigation-button');
                    tabs = R.insertAll(index + 1, subTabs, tabs);
                    subTabsNum = subTabs.length;
                } else {
                    subTabsNum--;
                }
                index++;
                setTimeout(runClicker, 500);
            }
        }
        runClicker();
    };

    exports.showModuleSchema = (checkRes) => {
        addEl(queryEl('body'), queryEl('.consistency-check-result-dialog'));
        $(queryEl('.consistency-check-result-dialog')).modal('show');

        const svg = d3.select('.image-place svg');
        const svgGroup = svg.append('g');
        const root = svgGroup.append('g');

        // define an arrow head
        svg.append('svg:defs')
            .append('svg:marker')
            .attr('id', 'end')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 10)
            .attr('refY', 0)
            .attr('markerWidth', 3) // marker settings
            .attr('markerHeight', 5)
            .attr('orient', 'auto')
            .style('fill', '#999')
            .style('stroke-opacity', 0.6) // arrowhead color
            .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5');

        const nodeDict = checkRes.nodes.reduce((dict, name, i) => {
            dict[name] = i;
            return dict;
        }, {});

        const nodeWidth = 170;
        const nodeHeight = 30;

        const name2Node = name => ({
            id: nodeDict[name],
            name,
            width: nodeWidth,
            height: nodeHeight
        });

        const pair2Edge = (pair, i) => ({
            id: i + checkRes.nodes.length,
            source: nodeDict[pair[0]],
            target: nodeDict[pair[1]]
        });

        const graph = {
            nodes: checkRes.nodes.map(name2Node),
            links: checkRes.edges.map(pair2Edge)
        };

        const layouter = klay.d3adapter();
        const width = 960;
        const height = 600;

        layouter
            .nodes(graph.nodes)
            .links(graph.links)
            .size([width, height])
            .transformGroup(root)
            .options({
                edgeRouting: 'ORTHOGONAL',
                intCoordinates: false
            })
            .defaultPortSize([2, 2])
            .start();

        const link = root.selectAll('.link')
            .data(graph.links)
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('d', 'M0 0')
            .attr('marker-end', 'url(#end)');

        // we group nodes along with their ports
        const node = root.selectAll('.node')
            .data(graph.nodes)
            .enter()
            .append('g');

        node.append('rect')
            .attr('class', (d) => {
                const details = checkRes.details[d.name];
                if (details === undefined || details.length === 0) {
                    return 'node valid';
                }
                return 'node invalid';
            })
            .attr('width', nodeWidth)
            .attr('height', nodeHeight)
            .attr('rx', 5)
            .attr('ry', 5)
            .attr('x', 0)
            .attr('y', 0);

        node.append('text')
            .attr('x', nodeWidth / 2)
            .attr('y', nodeHeight / 2)
            .attr('alignment-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .text(d => d.name)
            .attr('font-size', '4px');

        // ports
        const port = node.selectAll('.port')
            .data(d => d.ports)
            .enter()
            .append('rect')
            .attr('class', 'port')
            .attr('width', 2)
            .attr('height', 2)
            .attr('x', 0)
            .attr('y', 0);

        // apply layout
        layouter.on('finish', (d2) => {
        // apply edge routes
            link.transition().attr('d', (d) => {
                let path = '';
                path += `M${d.sourcePoint.x} ${d.sourcePoint.y} `;
                d.bendPoints.forEach((bp, i) => {
                    path += `L${bp.x} ${bp.y} `;
                });
                path += `L${d.targetPoint.x} ${d.targetPoint.y} `;
                return path;
            });

            // apply node positions
            node.transition()
                .attr('transform', d => `translate(${d.x} ${d.y})`);

            // apply port positions
            port.transition()
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });

        layouter.start();
    };
    
    exports.showDiffExample = () => {
        addEl(queryEl('body'), queryEl('.show-diff-dialog'));
        $(queryEl('.show-diff-dialog')).modal('show');
        
        DBMS.getLog(0, {
            action:"setMetaInfo",
            date:"",
            params:"",
            status:"OK",
            user:""
        }, (err, data) => {
            if (err) { Utils.handleError(err); return; }
            const el = clearEl(queryEl('.show-diff-dialog .container-fluid'));
            
            addEls(el, R.aperture(2, data.requestedLog).map(pair => {
                const row = qmte('.diff-row-tmpl');
                addEl(qee(row, '.first .user'), makeText(pair[0][1]));
                addEl(qee(row, '.first .time'), makeText(new Date(pair[0][2]).format('yyyy/mm/dd h:MM')));
                const firstText = JSON.parse(pair[0][4])[1];
                addEl(qee(row, '.first .text'), makeText(firstText));
                
                addEl(qee(row, '.last .user'), makeText(pair[1][1]));
                addEl(qee(row, '.last .time'), makeText(new Date(pair[1][2]).format('yyyy/mm/dd h:MM')));
                const lastText = JSON.parse(pair[1][4])[1];
                addEl(qee(row, '.last .text'), makeText(lastText));
                
                ////        const diff = JsDiff.diffChars(prevData[4] || '', rowData[4]);
                ////        const diff = JsDiff.diffWords(prevData[4] || '', rowData[4]);
//                const diff = JsDiff.diffWordsWithSpace(firstText, lastText);
                const diff = JsDiff.diffWordsWithSpace(lastText, firstText);
                const els = diff.map( part =>
                    [part.value, (part.added ? 'added' : (part.removed ? 'removed' : 'same'))]).map(pair => {
                    return addClasses(addEl(makeEl('span'), makeText(pair[0])), ['log-diff', pair[1]]);
                });
                addEls(qee(row, '.diff .text'), els);
                
                return row;
            }));
        })
    };
    
    const getAllSubsets = theArray => theArray.reduce((subsets, value) => 
        subsets.concat(subsets.map(set => [value,...set])),[[]]);
    
    exports.addGroupTestingData = () => {
        DBMS.createProfileItem('character', 'text', 'text', 0, () => '');
        DBMS.createProfileItem('character', 'string', 'string', 0, () => '');
        DBMS.createProfileItem('character', 'checkbox', 'checkbox', 0, () => '');
        DBMS.createProfileItem('character', 'number', 'number', 0, () => '');
        DBMS.createProfileItem('character', 'enum', 'enum', 0, () => '');
        DBMS.createProfileItem('character', 'multiEnum', 'multiEnum', 0, () => '');
        
        DBMS.updateDefaultValue("character","enum","1,2,3", () => '');
        DBMS.updateDefaultValue("character","multiEnum","1,2,3,4", () => '');
        
        
        const makeChar = (name, profileItem, value) => {
            DBMS.createProfile("character", name, () => '');
            DBMS.updateProfileField("character", name, profileItem, profileItem, value, () => '');
        }
        
        const makeGroup = (name, profileItem, obj) => {
            DBMS.createGroup(name, () => '');
            DBMS.saveFilterToGroup(name, [R.merge(obj, {"type":profileItem,"name":"profile-" + profileItem})], () => '');
        }
//        
//        
//        const enumValues = [1,2,3];
//        enumValues.map(value => makeChar('char enum ' + value, 'enum', String(value)));
//        getAllSubsets(enumValues).map( arr => {
//            const obj = arr.reduce( (acc, val) => {
//                acc[String(val)] = true;
//                return acc;
//            }, {});
//            makeGroup('group enum ' + arr.join(','), 'enum', {selectedOptions: obj});
//        });
//        
//        const multiEnumConditions = ['every','equal','some'];
        // bug in condition combination 
//        ['every']
//        ['every','equal']
//        ['every','some'] ...
        const multiEnumValues = [1,2,3];
        const multiEnumValues2 = [1,2,3,4];
        const multiEnumConditions = ['every','equal'];
        getAllSubsets(multiEnumValues2).map(value => makeChar('char multiEnum ' + value.join(','), 'multiEnum', String(value.join(','))));
        multiEnumConditions.map(condition => {
            getAllSubsets(multiEnumValues).map( arr => {
                const obj = arr.reduce( (acc, val) => {
                    acc[String(val)] = true;
                    return acc;
                }, {});
                makeGroup('group multiEnum ' + condition + ' ' + arr.join(','), 'multiEnum', {selectedOptions: obj, condition});
            });
        });
//        
//        
//        const numbers = [0,1,2,3,4];
//        const subNumbers = [1,2,3];
//        const numberConditions = ['greater','equal','lesser'];
//        numbers.map(value => makeChar('char number ' + value, 'number', (value)));
//        numberConditions.map(condition => {
//            subNumbers.map( num => {
//                makeGroup('group number ' + condition + ' ' + num, 'number', {num, condition});
//            });
//        });
//        
//        const checkboxes = [true, false];
//        checkboxes.map(value => makeChar('char checkbox ' + value, 'checkbox', value));
//        getAllSubsets(checkboxes).map( arr => {
//            const obj = arr.reduce( (acc, val) => {
//                acc[String(val)] = true;
//                return acc;
//            }, {});
//            makeGroup('group checkbox ' + arr.join(','), 'checkbox', {selectedOptions: obj});
//        });
//        
//        const chars = ['a','b','c','d'];
//        const subChars = ['a','b','c'];
//        getAllSubsets(chars).map(value => makeChar('char string ' + value.join(''), 'string', String(value.join(''))));
//        getAllSubsets(chars).map(value => makeChar('char text ' + value.join(''), 'text', String(value.join(''))));
//        
//        getAllSubsets(subChars).map( arr => {
//            makeGroup('group string ' + arr.join(''), 'string', {regexString: arr.join('')});
//        });
//        getAllSubsets(subChars).map( arr => {
//            makeGroup('group text ' + arr.join(''), 'text', {regexString: arr.join('')});
//        });
    }
})(this.TestUtils = {});

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

/* eslint-disable no-var,vars-on-top */

((exports) => {
    exports.createModalDialog = (root, onAction, opts) => {
        const commons = '.dialog-commons ';
        const el2 = wrapEl('div', qte(`${commons} .request-data-dialog-tmpl`));
        const el = qee(el2, '.modal');
        if (opts.dialogClass !== undefined) {
            addClass(el, opts.dialogClass);
        }
        const body = qee(el, '.modal-body');
        addEl(body, qte(`${commons} .${opts.bodySelector}`));
        if (opts.body !== undefined) {
            R.toPairs(opts.body).map(pair => setAttr(qee(body, pair[0]), 'l10n-id', pair[1]));
        }
        if (opts.initBody !== undefined) {
            opts.initBody(body);
        }
        addEl(body, qte(`${commons} .modal-error-block`));
        setAttr(qee(el, '.modal-title'), 'l10n-id', opts.dialogTitle);
        setAttr(qee(el, '.on-action-button'), 'l10n-id', opts.actionButtonTitle);
        L10n.localizeStatic(el);
        listen(qee(el, '.on-action-button'), 'click', onAction(el));
        el.showDlg = () => {
            clearError(el);
            $(el).modal('show');
            const focusable = qee(body, '.focusable');
            if(focusable !== null){
                setTimeout(() => focusable.focus(), 500);
            }
        };
        const onenterable = qees(body, '.onenterable');
        if(onenterable.length !== 0){
            onenterable.forEach(listenOnEnter(R.__, onAction(el)));
        }
        el.hideDlg = () => $(el).modal('hide');
        listen(qee(el, '.on-cancel-button'), 'click', () => {
            el.hideDlg()
            if(opts.onCancel) opts.onCancel();
        });
        listen(qee(el, '.on-close-button'), 'click', () => {
            el.hideDlg()
            if(opts.onCancel) opts.onCancel();
        });
        addEl(qe(root), el);
        return el;
    };

    exports.initTabPanel = (tabClazz, containerClazz) => {
        const containers = getEls(containerClazz);

        let i;
        for (i = 1; i < containers.length; i++) { // don't hide 1st element
            addClass(containers[i], 'hidden');
        }

        const tabButtons = getEls(tabClazz);

        addClass(tabButtons[0], 'active');

        for (i = 0; i < tabButtons.length; i++) {
            listen(tabButtons[i], 'click', tabButtonClick(tabButtons, containers));
        }
    };

    var tabButtonClick = (buttons, containers) => (event) => {
        for (let i = 0; i < buttons.length; i++) {
            setClassByCondition(buttons[i], 'active', event.target.id === buttons[i].id);
        }
        for (let i = 0; i < containers.length; i++) {
            hideEl(containers[i], `${event.target.id}Container` !== containers[i].id);
        }
    };

    exports.fillShowItemSelector = (selector, displayArray) => {
        let el;
        setAttr(selector, 'size', displayArray.length);
        displayArray.forEach((value) => {
            el = setProps(makeEl('option'), {
                selected: true,
            });
            hideEl(el, value.hidden);
            addEl(selector, addEl(el, makeText(value.name)));
        });
    };

    exports.fillShowItemSelector2 = (selector, optionGroups, setSize) => {
        let el, groupEl, counter = 0;
        addEls(selector, optionGroups.map((group) => {
            counter++;
            groupEl = setAttr(makeEl('optgroup'), 'label', group.displayName);
            addEls(groupEl, group.array.map((option) => {
                el = setProps(makeEl('option'), {
                    selected: true,
                });
                setAttr(el, 'value', option.name);
                counter++;
                return addEl(el, makeText(option.displayName));
            }));
            return groupEl;
        }));
        if(setSize) {
            setAttr(selector, 'size', counter);
        }
    };

//    exports.showSelectedEls = classKey => (event) => {
//        const t1 = performance.now();
//        const el = event.target;
//        let els, i, j;
//        for (i = 0; i < el.options.length; i += 1) {
//            els = getEls(classKey + i);
//            for (j = 0; j < els.length; j++) {
//                hideEl(els[j], !el.options[i].selected);
//            }
//        }
//        console.log('showSelectedEls time ' + (performance.now() - t1) + ' ms');
//    };
//    
//    exports.showSelectedEls2 = (root, classKey) => (event) => {
//        const t1 = performance.now();
//        const el = event.target;
//        let els, i, j;
//        for (i = 0; i < el.options.length; i += 1) {
//            els = queryEls(root + ' .' + classKey + i);
//            for (j = 0; j < els.length; j++) {
//                hideEl(els[j], !el.options[i].selected);
//            }
//        }
//        console.log('showSelectedEls2 time ' + (performance.now() - t1) + ' ms');
//    };
    
    exports.showSelectedEls3 = (root, classKey, attr) => (event) => {
        const t1 = performance.now();
        const el = event.target;
        let i, j;
        const map = {};
        for (i = 0; i < el.options.length; i += 1) {
            map[i] = el.options[i].selected;
        }
        const els = queryEls(root + ' .' + classKey);
        els.forEach(el2 => {
            showEl(el2, map[getAttr(el2, attr)]);
        });
        console.log('showSelectedEls3 time ' + (performance.now() - t1) + ' ms');
    };

    exports.initSelectorFilters = () => {
        queryEls('[selector-filter]').forEach((el) => {
            const sel = queryEl(getAttr(el, 'selector-filter'));
            el.value = '';
            setAttr(el, 'l10n-placeholder-id', 'constant-filter');
            addClass(el, 'form-control margin-bottom-8');
            listen(el, 'input', filterOptions(sel));
        });
    };

    var filterOptions = sel => (event) => {
        let val = event.target.value;
        let i, opt;
//        val = CommonUtils.globStringToRegex(val.trim().toLowerCase());
        val = val.toLowerCase();
        for (i = 0; i < sel.options.length; i += 1) {
            opt = sel.options[i];
//            const isVisible = opt.innerHTML.toLowerCase().search(val) !== -1;
            const isVisible = opt.innerHTML.toLowerCase().indexOf(val) !== -1;
            if (!isVisible) {
                opt.selected = false;
            }
            hideEl(opt, !isVisible);
            //                setClassByCondition(opt, "hidden", opt.innerHTML.toLowerCase().search(val) === -1);
        }
        sel.dispatchEvent(new Event('change'));
    };

    exports.initPanelToggler = (el) => {
        const attr = getAttr(el, 'panel-toggler');
        addClass(el, 'expanded');
        const sel = document.querySelector(attr);
        if (sel == null) {
            Utils.alert(`Panel toggler is broken: ${attr}`);
        }
        listen(el, 'click', togglePanel(el, sel));
    };

    exports.initPanelTogglers = el => qees(el || document, '[panel-toggler]').forEach(exports.initPanelToggler);

    exports.attachPanelToggler = (header, content, callback) => {
        addClass(header, 'expanded');
        listen(header, 'click', (event) => {
            if (callback) {
                callback(event, () => {
                    togglePanel(header, content)(event);
                });
            } else {
                togglePanel(header, content)(event);
            }
        });
    };

    var togglePanel = (el, sel) => (event) => {
        const isExpanded = hasClass(el, 'expanded');
        removeClasses(el, ['expanded', 'collapsed']);
        addClass(el, isExpanded ? 'collapsed' : 'expanded');
        toggleClass(sel, 'hidden');
    };

    exports.makeEventTimePicker = (opts) => {
        const input = makeEl('input');
        R.ap([addClass(input)], opts.extraClasses);
        addClass(input, 'eventTime');
        input.value = opts.eventTime;

        input.eventIndex = opts.index;

        const pickerOpts = {
            lang: L10n.getLang(),
            mask: true,
            startDate: new Date(opts.preGameDate),
            endDate: new Date(opts.date),
            onChangeDateTime: opts.onChangeDateTimeCreator(input),
        };

        if (opts.eventTime !== '') {
            pickerOpts.value = opts.eventTime;
        } else {
            pickerOpts.value = opts.date;
            addClass(input, 'defaultDate');
        }

        jQuery(input).datetimepicker(pickerOpts);
        return input;
    };

    exports.makeEventTimePicker2 = (input, opts) => {
        input.value = opts.eventTime;

        input.eventIndex = opts.index;

        const pickerOpts = {
            lang: L10n.getLang(),
            mask: true,
            startDate: new Date(opts.preGameDate),
            endDate: new Date(opts.date),
            onChangeDateTime: opts.onChangeDateTimeCreator(input),
        };

        if (opts.eventTime !== '') {
            pickerOpts.value = opts.eventTime;
        } else {
            pickerOpts.value = opts.date;
            addClass(input, 'defaultDate');
        }

        jQuery(input).datetimepicker(pickerOpts);
        return input;
    };

    // bug about setting 0900 years in Braavos game is event date. Fixed in production.
    //  exports.makeEventTimePicker = function (opts) {
    //      var input = makeEl("input");
    //      R.ap([addClass(input)], opts.extraClasses);
    //      addClass(input, "eventTime");
    //      input.value = opts.eventTime;
    //
    //      input.eventIndex = opts.index;
    //
    //      var pickerOpts = {
    //          lang : L10n.getLang(),
    //          mask : true,
    //          startDate : new Date(opts.preGameDate),
    //          endDate : new Date(opts.date),
    //          onChangeDateTime : opts.onChangeDateTimeCreator(input),
    //      };
    //
    //      var picker = jQuery(input).datetimepicker(pickerOpts);
    //
    //      var value;
    //      if (opts.eventTime !== "") {
    //          value = new Date(opts.eventTime);
    //      } else {
    //          value = opts.date;
    //          addClass(input, "defaultDate");
    //      }
    //
    //      picker.value = value;
    //
    //
    //      return input;
    //  };

    exports.initTextAreas = (sel) => {
        R.ap([exports.attachTextareaResizer], queryEls(sel));
    };

    exports.refreshTextAreas = (sel) => {
        R.ap([exports.resizeTextarea], queryEls(sel).map(el => ({ target: el })));
    };

    exports.attachTextareaResizer = (input) => {
        listen(input, 'keydown', exports.resizeTextarea);
        listen(input, 'paste', exports.resizeTextarea);
        listen(input, 'cut', exports.resizeTextarea);
        listen(input, 'change', exports.resizeTextarea);
        listen(input, 'drop', exports.resizeTextarea);
    };

    exports.resizeTextarea = (ev) => {
        const that = ev.target;
        that.style.height = '24px';
        that.style.height = `${that.scrollHeight + 12}px`;
    };

    exports.resizeTextarea2 = (that) => {
        that.style.height = '24px';
        that.style.height = `${that.scrollHeight + 12}px`;
    };

    exports.populateAdaptationTimeInput = (input, storyName, event, characterName, isEditable) => {
        setClassByCondition(input, 'notEditable', !isEditable);
        input.value = event.characters[characterName].time;
        input.dataKey = JSON.stringify([storyName, event.index, characterName]);
        listen(input, 'change', onChangePersonalTimeDelegate);
        return input;
    };

    var onChangePersonalTimeDelegate = (event) => {
        const dataKey = JSON.parse(event.target.dataKey);
        const time = event.target.value;
        DBMS.setEventAdaptationProperty(dataKey[0], dataKey[1], dataKey[2], 'time', time, Utils.processError());
    };

    exports.populateReadyCheckbox = (div, id, checked, isEditable, callback) => {
        const input = qee(div, 'input');
        setClassByCondition(input, 'notEditable', !isEditable);
        input.checked = checked;
        input.id = id;
        listen(input, 'change', callback);
        setAttr(qee(div, 'label'), 'for', input.id);
        return div;
    };

    exports.onChangeAdaptationReadyStatus2 = callback => (event) => {
        const dataKey = JSON.parse(event.target.id);
        const value = !hasClass(event.target, 'btn-primary');
        DBMS.setEventAdaptationProperty(dataKey[0], dataKey[1], dataKey[2], 'ready', value, (err) => {
            if (err) { Utils.handleError(err); return; }
            setClassByCondition(event.target, 'btn-primary', value);
            callback(value);
        });
    };

    exports.makePanelCore = (title, content) => {
        const panel = addClasses(makeEl('div'), ['panel', 'panel-default']);
        const h3 = addClass(addEl(makeEl('h3'), title), 'panel-title');
        const a = setAttr(makeEl('a'), 'href', '#/');
        setAttr(a, 'panel-toggler', '');
        const headDiv = addClass(makeEl('div'), 'panel-heading');
        addEl(panel, addEl(headDiv, addEl(a, h3)));
        const contentDiv = addClass(makeEl('div'), 'panel-body');
        addEl(panel, addEl(contentDiv, content));
        return {
            panel,
            contentDiv,
            a
        };
    };

    exports.makeProfileTable = (profileStructure, profile) => {
        const container = qmte('.profile-editor-container-tmpl');
        addClass(container, 'profile-table');
        let value;
        return addEls(container, profileStructure.filter(element => element.doExport).map((element) => {
            switch (element.type) {
            case 'text':
                value = addClass(makeEl('span'), 'briefingTextSpan');
                addEl(value, makeText(profile[element.name]));
                break;
            case 'enum':
            case 'multiEnum':
            case 'number':
            case 'string':
                value = makeText(profile[element.name]);
                break;
            case 'checkbox':
                value = makeText(constL10n(Constants[profile[element.name]]));
                break;
            default:
                throw new Error(`Unexpected type ${element.type}`);
            }
            const row = qmte('.profile-editor-row-tmpl');
            addEl(qee(row, '.profile-item-name'), makeText(element.name));
            addEl(qee(row, '.profile-item-input'), value);
            return row;
        }));
    };

    exports.makeTableRow = (col1, col2) => addEls(makeEl('tr'), [addEl(makeEl('td'), col1), addEl(makeEl('td'), col2)]);

    exports.checkAndGetEntitySetting = (settingsPath, names) => {
        if (names.length === 0) return null;
        const settings = DBMS.getSettings();
        if (!settings[settingsPath]) {
            settings[settingsPath] = {
                name: names[0].value
            };
        }
        let { name } = settings[settingsPath];
        const rawNames = names.map(R.prop('value'));
        if (rawNames.indexOf(name) === -1) {
            settings[settingsPath].name = names[0].value;
            name = names[0].value;
        }
        return name;
    };

    exports.updateEntitySetting = (settingsPath, name) => {
        const settings = DBMS.getSettings();
        if(settings[settingsPath] === undefined) {
            settings[settingsPath] = {};
        }
        settings[settingsPath].name = name;
    };
    
    exports.scrollTo = (container, element) => {
        const domRect = element.getBoundingClientRect();
        const scrollTop = container.scrollTop;
        const scrollBottom = container.scrollTop + container.clientHeight;
        const condition = element.offsetTop < scrollTop || (element.offsetTop + domRect.height) > scrollBottom;
        
        if(condition){
            const from = container.scrollTop;
            const to = element.offsetTop - container.clientHeight/2 + domRect.height/2;
            
            Utils.animate({
                duration: 500,
                timing: Timing.makeEaseInOut(Timing.poly(4)),
                draw: function(progress) {
                    container.scrollTop = from + (to - from) * progress;
                }
            });
        }
    };
})(this.UI = {});

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

// TODO need to lint utils with NIMS fixes
/* eslint-disable */

const strFormat = R.curry(CommonUtils.strFormat);

function getL10n(key) {
    return L10n.getValue(key);
}

function constL10n(key) {
    return L10n.getValue(`constant-${key}`);
}

function isEmpty(obj) {
    return (Object.getOwnPropertyNames(obj).length === 0);
}

const addClass = R.curry((o, c) => {
    const re = new RegExp(`(^|\\s)${c}(\\s|$)`, 'g');
    if (re.test(o.className)) return o;
    o.className = (`${o.className} ${c}`).replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
    return o;
});

const addClasses = R.curry((o, c) => {
    R.ap([addClass(o)], c);
    return o;
});

const hasClass = R.curry((o, c) => {
    const re = new RegExp(`(^|\\s)${c}(\\s|$)`, 'g');
    return (re.test(o.className));
});

const removeClass = R.curry((o, c) => {
    const re = new RegExp(`(^|\\s)${c}(\\s|$)`, 'g');
    o.className = o.className.replace(re, '$1').replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
    return o;
});

const removeClasses = R.curry((o, c) => {
    R.ap([removeClass(o)], c);
    return o;
});

const toggleClass = R.curry((o, c) => {
    if (hasClass(o, c)) {
        removeClass(o, c);
    } else {
        addClass(o, c);
    }
});

const setClassByCondition = R.curry((o, c, condition) => {
    if (condition) {
        addClass(o, c);
    } else {
        removeClass(o, c);
    }
    return o;
});

const setClassIf = setClassByCondition;

const showEl = (el, condition) => setClassByCondition(el, 'hidden', !condition);
const hideEl = (el, condition) => setClassByCondition(el, 'hidden', condition);

function getEl(id) {
    return document.getElementById(id);
}

function queryEl(sel) {
    return document.querySelector(sel);
}

const qe = queryEl;

// query template element
function qte(sel){
    return document.querySelector(sel).content.cloneNode(true);
}

// query materialize template element
function qmte(sel){
    return addEl(makeEl('div'), qte(sel)).firstChild;
}

function queryEls(sel) {
    return nl2array(document.querySelectorAll(sel));
}

const qes = queryEls;

function queryElEl(el, sel) {
    return el.querySelector(sel);
}

const qee = R.curry(queryElEl);

function queryElEls(el, sel) {
    return nl2array(el.querySelectorAll(sel));
}

const qees = R.curry(queryElEls);

function getEls(clazz) {
    return document.getElementsByClassName(clazz);
}

function makeEl(elTag) {
    return document.createElement(elTag);
}

const wrapEl = R.curry((elTag, el) => {
    return addEl(makeEl(elTag), el);
})

const wrapEls = R.curry((elTag, els) => {
    return addEls(makeEl(elTag), els);
})

function makeText(text) {
    return document.createTextNode(text);
}

const addEl = R.curry((parent, child) => {
    parent.appendChild(child);
    return parent;
});
const addEls = R.curry((parent, children) => {
    R.ap([addEl(parent)], children);
    return parent;
});

const makeOpt = function (label) {
    const option = makeEl('option');
    addEl(option, (makeText(label)));
    return option;
};

const setAttr = R.curry((el, name, value) => {
    el.setAttribute(name, value);
    return el;
});

const setStyle = R.curry((el, name, value) => {
    el.style.setProperty(name, value);
    return el;
});

const setImportantStyle = R.curry((el, name, value) => {
    el.style.setProperty(name, value, 'important');
    return el;
});

function delAttr(el, name) {
    el.removeAttribute(name);
    return el;
}

const getAttr = R.curry((el, name) => {
    return el.getAttribute(name);
});

const setProp = R.curry((el, key, value) => {
    el[key] = value;
    return el;
});

const setProps = R.curry((el, map) => {
    for (const key in map) {
        setProp(el, key, map[key]);
    }
    return el;
});

function clearEl(el) {
    Utils.removeChildren(el);
    return el;
}

function clearEls(els){
    return els.map(clearEl)
}

function passEls(src, dst) {
    for (let i = 0; i < src.children.length; i++) {
        addEl(dst, src.children[i]);
    }
}

const listen = R.curry((el, event, listener) => {
    el.addEventListener(event, listener);
    return el;
});

const listenOnEnter = R.curry((el, callback) => {
    listen(el, 'keydown', (e) => {
        if (e.keyCode === 13) {
            if(e.iAmNotAlone) {
                throw new Error('Oh dear!');
            }
            e.iAmNotAlone = true;
            
            callback();
        }
    });
});

const fillSelector = R.curry((sel, data) => addEls(sel, data.map((item) => {
    const opt = makeEl('option');
    addEl(opt, makeText(item.name));
    if (item.value !== undefined) { opt.value = item.value; }
    if (item.selected !== undefined) { opt.selected = true; }
    if (item.className !== undefined) { addClass(opt, item.className); }
    return opt;
})));

function nl2array(nodeList) {
    return Array.prototype.slice.call(nodeList);
}

const remapProps = R.curry((outKeys, pickKeys, obj) => R.compose(R.zipObj(outKeys), R.values, R.pick(pickKeys))(obj));

const remapProps4Select2 = remapProps(['id', 'text'], ['value', 'displayName']);
const remapProps4Select = remapProps(['value', 'name'], ['value', 'displayName']);

const getSelect2DataCommon = R.curry((preparator, obj) => R.compose(R.zipObj(['data']), R.append(R.__, []), R.map(preparator))(obj));

const getSelect2Data = getSelect2DataCommon(remapProps4Select2);

const makeSelect2Opt = R.compose(R.zipObj(['id', 'text']), R.repeat(R.__, 2));
const arr2Select2 = R.compose(R.assoc('data', R.__, {}), R.map(makeSelect2Opt));
const arr2Select = R.map(R.compose(R.zipObj(['value', 'name']), R.repeat(R.__, 2)));
const constArr2Select = R.map(R.compose(R.zipObj(['value', 'name']), name => [name, constL10n(name)]));

const getSelectedRadio = function (el, query) {
    return queryElEls(el, query).find(R.prop('checked'));
};

const debugInterceptor = function (callback) {
    return function () {
        console.log(JSON.stringify(arguments[0]));
        callback(...arguments);
    };
};

const Utils = {};

/** opts
    tooltip - add tooltip to button, used for iconic buttons
    id - set button id
    mainPage - enable view as first page - deprecated. Use Utils.setFirstTab instead
    toggle - toggle content, associated with button
*/
Utils.addView = function (containers, name, view, opts2) {
    const opts = opts2 || {};
    view.init();
    const buttonClass = 'navigation-button';
    containers.root.views[name] = view;
    const button = makeEl('button');
    function delegate() {
        $(button).attr('data-original-title', L10n.getValue(`header-${name}`));
    }
    if (opts.tooltip) {
        L10n.onL10nChange(delegate);
        $(button).tooltip({
            title: L10n.getValue(`header-${name}`),
            placement: 'bottom'
        });
    } else {
        addEl(button, makeText(L10n.getValue(`header-${name}`)));
        setAttr(button, 'l10n-id', `header-${name}`);
    }
    addClass(button, buttonClass);
    addClass(button, `-test-${name}`);
    addClass(button, `-toggle-class-${name}`);
    if (opts.clazz) {
        addClass(button, opts.clazz);
    }
    containers.navigation.appendChild(button);

    const onClickDelegate = function (view2) {
        return function (evt) {
            //Tests.run();
            const elems = containers.navigation.getElementsByClassName(buttonClass);
            if (opts.toggle) {
                const els = getEls(`-toggle-class-${name}`);
                for (let i = 0; i < els.length; i++) {
                    if (evt.target.isEqualNode(els[i])) {
                        continue;
                    }
                    if (hasClass(els[i], 'active')) {
                        els[i].click();
                    }
                }
            }

            const isActive = hasClass(evt.target, 'active');
            for (let i = 0; i < elems.length; i++) {
                removeClass(elems[i], 'active');
            }
            if (!opts.toggle || (opts.toggle && !isActive)) {
                addClass(evt.target, 'active');

                passEls(containers.content, getEl('warehouse'));
                containers.content.appendChild(view2.content);
                removeClass(containers.content, 'hidden');
                containers.root.currentView = view2;
                view2.refresh();
            } else {
                removeClass(evt.target, 'active');
                passEls(containers.content, getEl('warehouse'));
                containers.root.currentView = null;
                addClass(containers.content, 'hidden');
            }
        };
    };

    button.addEventListener('click', onClickDelegate(view));

    // deprecated. Use Utils.setFirstTab instead
    if (opts.mainPage) {
        Utils.setFirstTab(containers, {button, view});
    }
    return {button, view};
};

Utils.setFirstTab = function(containers, opts){
    addClass(opts.button, 'active');
    containers.content.appendChild(opts.view.content);
    containers.root.currentView = opts.view;
}

Utils.alert = function (message) {
    vex.dialog.alert(message);
};

const setError = (el, err) => addEl(clearEl(qee(el, '.error-msg')), makeText(Utils.handleErrorMsg(err)));
const clearError = (el) => clearEl(qee(el, '.error-msg'));

Utils.confirm = function (message, onOk, onCancel) {
    vex.dialog.confirm({
        message,
        callback: (val) => {
            if (val) {
                if (onOk) onOk();
            } else if (onCancel) onCancel();
        }
    });
};

Utils.removeChildren = function (myNode) {
    if (!myNode) {
        return;
    }
    while (myNode.firstChild) {
        myNode.removeChild(myNode.firstChild);
    }
};

Utils.processError = function (callback) {
    return function (err) {
        if (err) {
            Utils.handleError(err);
            return;
        }

        if (callback) {
            const arr = [];
            for (let i = 1; i < arguments.length; i++) {
                arr.push(arguments[i]);
            }
            callback(...arr);
        }
    };
};

Utils.handleErrorMsg = function (err) {
    const checkErrorType = R.curry((err2, name) => err2 instanceof Errors[name] || (err2.name && err2.name === name));
    if (R.keys(Errors).some(checkErrorType(err))) {
        const params = err.parameters.map(val => {
            return L10n.hasValue(val) ? L10n.getValue(val) : val;
        });
        return strFormat(getL10n(err.messageId), params);
    } else if (typeof err === 'object') {
        return err.message;
    }
    return err;
};

Utils.handleError = err => Utils.alert(Utils.handleErrorMsg(err));

Utils.enableEl = R.curry((el, condition) => {
    const key = el.tagName.toLowerCase() === 'textarea' ? 'readonly' : 'disabled';
    if (condition) {
        el.removeAttribute(key);
    } else {
        el.setAttribute(key, key);
    }
});

Utils.enable = function (root, className, condition) {
    nl2array(root.getElementsByClassName(className)).map(Utils.enableEl(R.__, condition));
};

Utils.charOrdAObject = CommonUtils.charOrdAFactory(a => a.displayName.toLowerCase());

Utils.rebuildSelector = function (selector, names) {
    clearEl(selector);
    names.forEach((nameInfo) => {
        const option = makeEl('option');
        option.appendChild(makeText(nameInfo.displayName));
        option.value = nameInfo.value;
        selector.appendChild(option);
    });
};

Utils.rebuildSelectorArr = function (selector, names) {
    clearEl(selector);
    names.forEach((name) => {
        const option = makeEl('option');
        option.appendChild(makeText(name));
        selector.appendChild(option);
    });
};

// from https://learn.javascript.ru/js-animation
Utils.animate = (options) => {
    const start = performance.now();

    requestAnimationFrame(function animate(time) {
        // timeFraction from 0 to 1
        let timeFraction = (time - start) / options.duration;
        if (timeFraction > 1) timeFraction = 1;
        
        // current animation state
        const progress = options.timing(timeFraction)
        
        options.draw(progress);
        
        if (timeFraction < 1) {
            requestAnimationFrame(animate);
        }
    });
}

const Timing = {};

// call examples
//timing: Timing.linear,
//timing: Timing.quad,
//timing: Timing.circ,
//timing: Timing.bounce,
//timing: Timing.makeEaseOut(Timing.bounce),
//timing: Timing.makeEaseInOut(Timing.bounce),
//timing: Timing.back(3.5),
//timing: Timing.elastic(1.5),
//timing: Timing.makeEaseInOut(Timing.poly(4)),

Timing.linear = (timeFraction) => {
    return timeFraction;
}

Timing.quad = ( progress) => {
    return Math.pow(progress, 2)
}

Timing.poly = R.curry((x, progress) => {
    return Math.pow(progress, x)
})

Timing.circ = (timeFraction) => {
    return 1 - Math.sin(Math.acos(timeFraction))
}

Timing.back = R.curry((x, timeFraction) => {
    return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)
})

Timing.bounce = (timeFraction) => {
    for (var a = 0, b = 1, result; 1; a += b, b /= 2) {
        if (timeFraction >= (7 - 4 * a) / 11) {
            return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
        }
    }
}

Timing.elastic = (x, timeFraction) => {
    return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)
}

Timing.makeEaseOut = (timing) => {
    return function(timeFraction) {
        return 1 - timing(1 - timeFraction);
    }
}

Timing.makeEaseInOut = (timing) => {
    return function(timeFraction) {
        if (timeFraction < .5) {
            return timing(2 * timeFraction) / 2;
        } else {
            return (2 - timing(2 * (1 - timeFraction))) / 2;
        }
    }
}

String.prototype.endsWith = function (suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

// from date format utils
//For convenience...
Date.prototype.format = function (mask, utc) {
    return dateFormat(this, mask, utc);
};

/*Copyright 2015, 2018 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

/*global
Utils, Overview, Profiles, Stories, Adaptations, Briefings, Timeline, SocialNetwork, FileUtils
 */

'use strict';

((exports) => {
    const state = {};
    state.views = {};
    state.firstBaseLoad = MODE === 'Standalone';
    
    const BACKUP_NUMBER = 4;
    const BACKUP_INTERVAL = 60000*10; // 10 min

    const btnOpts = {
        tooltip: true,
        className: 'mainNavButton'
    };

    const initPage = () => {
        L10n.init();
        L10n.onL10nChange(() => state.currentView.refresh());
        UI.initSelectorFilters();
        UI.initPanelTogglers();
        L10n.localizeStatic();
        function updateDialogs() {
            vex.dialog.buttons.YES.text = getL10n('common-ok');
            vex.dialog.buttons.NO.text = getL10n('common-cancel');
        }
        updateDialogs();
        L10n.onL10nChange(updateDialogs);
    };

    const protoExpander = (arr) => {
        function protoCarrier() {}
        arr.forEach(name => (protoCarrier.prototype[name] = (() => 1)));
        return protoCarrier;
    };
    const playerArr = [
        'getPlayersOptions',
        'getWelcomeText',
        'getPlayerProfileInfo',
        'createCharacterByPlayer',
        'updateProfileField',
        'getRoleGridInfo'];

    exports.refresh = () => state.currentView.refresh();

    exports.onPlayerPageLoad = () => {
        initPage();
        const RemoteDBMS = makeRemoteDBMS(protoExpander(playerArr));
        window.DBMS = new RemoteDBMS();
        stateInit();
        Utils.addView(state.containers, 'player', Player, { mainPage: true });
        addEl(state.navigation, addClass(makeEl('div'), 'nav-separator'));
        Utils.addView(state.containers, 'about', About);
        //        addEl(state.navigation, makeL10nButton());
        addEl(state.navigation, makeButton('logoutButton icon-button', 'logout', postLogout, btnOpts));
        state.currentView.refresh();
    };

    exports.onIndexPageLoad = () => {
        initPage();
        const RemoteDBMS = makeRemoteDBMS(protoExpander(['getPlayersOptions', 'getRoleGridInfo']));
        window.DBMS = new RemoteDBMS();
        stateInit();
        DBMS.getPlayersOptions((err, playersOptions) => {
            if (err) { Utils.handleError(err); return; }
            addEl(state.navigation, addClass(makeEl('div'), 'nav-separator'));
            Utils.addView(state.containers, 'enter', Enter, { mainPage: true });
            if (playersOptions.allowPlayerCreation) {
                Utils.addView(state.containers, 'sign-up', SignUp);
            }
            Utils.addView(state.containers, 'about', About);
            //            addEl(state.navigation, makeL10nButton());
            state.currentView.refresh();
        });
    };
    
    exports.onOrganizerPageLoad = () => {
        initPage();
        const LocalDBMS = makeLocalDBMS(true);
        if (MODE === 'Standalone') {
            window.DBMS = new LocalDBMS();
            window.DBMS = makeLocalDBMSWrapper(window.DBMS);
//            DBMS.setDatabase(DemoBase.data, onBaseLoaded);
            runBaseSelectDialog();
        } else if (MODE === 'NIMS_Server') {
            const RemoteDBMS = makeRemoteDBMS(LocalDBMS);
            window.DBMS = new RemoteDBMS();
            consistencyCheck((checkResult) => {
                consistencyCheckAlert(checkResult);
                onDatabaseLoad();
            });
        }
    };
    
    function runBaseSelectDialog() {
        const dbDialog = queryEl('.set-database-dialog');
        addEl(queryEl('body'), dbDialog);
        listen(qee(dbDialog, '.on-action-button'), 'click', (event) => {
            $(dbDialog).modal('hide');
        });
        
        readLocalBases().then((browserBases) => {
            addEls(qee(dbDialog, '.modal-body .backup-bases'), (browserBases || []).map((base,i) => {
                const baseSelect = qmte('.backup-base-tmpl');
                const input = qee(baseSelect, 'input');
                setAttr(input, 'value', "browserBackup" + i); 
                setAttr(input, 'id', "dbSourceBrowserBackup" + i);
                input.base = base;
                setAttr(qee(baseSelect, 'label'), 'for', "dbSourceBrowserBackup" + i);
                const date = new Date(base.Meta.saveTime).format('dd mmm yyyy HH:MM:ss');
                addEl(qee(baseSelect, '.base-name'), makeText(base.Meta.name + ' (' + date + ')'));
                return baseSelect;
            }));
            
            qee(dbDialog, 'input[name=dbSource]').checked = true;
            qee(dbDialog, '#dbSourceDemoBase').base = CommonUtils.clone(DemoBase.data);
            qee(dbDialog, '#dbSourceEmptyBase').base = CommonUtils.clone(EmptyBase.data);
            
            addEl(qee(dbDialog, '.demo-base-name'), makeText(DemoBase.data.Meta.name));
            
            const dialogOnBaseLoad = err => {
                if (err) { Utils.handleError(err); return; }
                $(dbDialog).modal('hide');
                onBaseLoaded(err);
            }
            
            initBaseLoadBtn(qee(dbDialog, '.upload-db'), qee(dbDialog, '.upload-db input'), dialogOnBaseLoad);
            
            listen(qee(dbDialog, '.on-action-button'), 'click', () => {
                const base = getSelectedRadio(dbDialog, 'input[name=dbSource]').base;
                DBMS.setDatabase(base, dialogOnBaseLoad);
            });
            
            L10n.localizeStatic(dbDialog);
            
            $(dbDialog).modal({
                backdrop: 'static'
            });
        }).catch(err => console.error(err));
    }

    function consistencyCheckAlert(checkResult) {
        if (checkResult.errors.length > 0) {
            Utils.alert(getL10n('overview-consistency-problem-detected'));
        } else {
            console.log('Consistency check didn\'t find errors');
        }
    }

    function consistencyCheck(callback) {
        DBMS.getConsistencyCheckResult((err, checkResult) => {
            if (err) { Utils.handleError(err); return; }
            checkResult.errors.forEach(CommonUtils.consoleErr);
            callback(checkResult);
        });
    }

    function stateInit() {
        state.navigation = getEl('navigation');
        state.containers = {
            root: state,
            navigation: state.navigation,
            content: getEl('contentArea')
        };
    }

    function onDatabaseLoad() {
        PermissionInformer.refresh((err) => {
            if (err) { Utils.handleError(err); return; }

            PermissionInformer.isAdmin((err2, isAdmin) => {
                if (err2) { Utils.handleError(err2); return; }
                
                $.datetimepicker.setDateFormatter('moment');

                let button;
                stateInit();

                const tabs = {};
                const firstTab = 'Overview';

                const addView = (containers, btnName, viewName, opts) => {
                    tabs[viewName] = {
                        viewName,
                        viewRes: Utils.addView(containers, btnName, window[viewName], opts)
                    };
                };

                addView(state.containers, 'overview', 'Overview');
                //                addView(state.containers, 'profiles', 'Profiles');
                addView(state.containers, 'characters', 'Characters');
                addView(state.containers, 'players', 'Players');
                addView(state.containers, 'stories', 'Stories');
                addView(state.containers, 'adaptations', 'Adaptations');
                addView(state.containers, 'briefings', 'Briefings');
                addView(state.containers, 'relations', 'Relations');

                addEl(state.navigation, addClass(makeEl('div'), 'nav-separator'));

                addView(state.containers, 'timeline', 'Timeline', { clazz: 'timelineButton icon-button', tooltip: true });
                addView(state.containers, 'social-network', 'SocialNetwork', { clazz: 'socialNetworkButton icon-button', tooltip: true });
                addView(state.containers, 'profile-filter', 'ProfileFilter', { clazz: 'filterButton icon-button', tooltip: true });
                addView(state.containers, 'groups', 'GroupProfile', { clazz: 'groupsButton icon-button', tooltip: true });
                addView(state.containers, 'textSearch', 'TextSearch', { clazz: 'textSearchButton icon-button', tooltip: true });
                addView(state.containers, 'roleGrid', 'RoleGrid', { clazz: 'roleGridButton icon-button', tooltip: true });

                addEl(state.navigation, addClass(makeEl('div'), 'nav-separator'));

                if (MODE === 'NIMS_Server') {
                    addView(state.containers, 'admins', 'AccessManager', { clazz: 'accessManagerButton icon-button', tooltip: true });
                }
                addView(state.containers, 'logViewer', 'LogViewer2', { clazz: 'logViewerButton icon-button', tooltip: true });

                addEl(state.navigation, addClass(makeEl('div'), 'nav-separator'));

                if (isAdmin) {
                    button = makeButton('dataLoadButton icon-button', 'open-database', null, btnOpts);
                    const input = makeEl('input');
                    input.type = 'file';
                    addClass(input, 'hidden');
                    setAttr(input, 'tabindex', -1);
                    button.appendChild(input);
                    
                    initBaseLoadBtn(button, input, onBaseLoaded);
                    addEl(state.navigation, button);
                }

                addEl(state.navigation, makeButton('dataSaveButton icon-button', 'save-database', FileUtils.saveFile, btnOpts));
                if (MODE === 'Standalone') {
                    addEl(state.navigation, makeButton('newBaseButton icon-button', 'create-database', FileUtils.makeNewBase(onBaseLoaded), btnOpts));
                }
//                addEl(state.navigation, makeButton('mainHelpButton icon-button', 'docs', FileUtils.openHelp, btnOpts));

                //                addEl(state.navigation, makeL10nButton());

//                addEl(state.navigation, makeButton('testButton icon-button', 'test', TestUtils.runTests, btnOpts));
//                addEl(state.navigation, makeButton('checkConsistencyButton icon-button', 'checkConsistency', checkConsistency, btnOpts));
//                addEl(state.navigation, makeButton('checkConsistencyButton icon-button', 'showDbmsConsistencyState', showDbmsConsistencyState, btnOpts));
//                addEl(state.navigation, makeButton('clickAllTabsButton icon-button', 'clickAllTabs', TestUtils.clickThroughtHeaders, btnOpts));
//                addEl(state.navigation, makeButton('clickAllTabsButton icon-button', 'showDiff', TestUtils.showDiffExample, btnOpts));
                if (MODE === 'NIMS_Server') {
                    addEl(state.navigation, makeButton('logoutButton icon-button', 'logout', postLogout, btnOpts));
                }
                addEl(state.navigation, makeButton('refreshButton icon-button', 'refresh', () => state.currentView.refresh(), btnOpts));

                Utils.setFirstTab(state.containers, tabs[firstTab].viewRes);

                state.currentView.refresh();
                if (MODE === 'Standalone') {
                    addBeforeUnloadListener();
                    localAutoSave();
                }
//                FileUtils.makeNewBase();
//                state.currentView.refresh();
                //                                runTests();
            });
        });
    }
    
    function onBaseLoaded(err3) {
        if (err3) { Utils.handleError(err3); return; }
        consistencyCheck((checkResult) => {
            consistencyCheckAlert(checkResult);
            if(state.firstBaseLoad){
                onDatabaseLoad();
                state.firstBaseLoad = false;
            } else {
                state.currentView.refresh();
            }
        });
    }
    
    function initBaseLoadBtn(button, input, onBaseLoaded) {
        button.addEventListener('change', FileUtils.readSingleFile(onBaseLoaded), false);
        button.addEventListener('click', (e) => {
            input.value = '';
            input.click();
            //                    e.preventDefault(); // prevent navigation to "#"
        });
    }

    function makeL10nButton() {
        const l10nBtn = makeButton('toggleL10nButton', 'l10n', L10n.toggleL10n, btnOpts);
        const setIcon = () => {
            l10nBtn.style.backgroundImage = strFormat('url("./images/{0}.svg")', [getL10n('header-dictionary-icon')]);
        };
        L10n.onL10nChange(setIcon);
        setIcon();
        return l10nBtn;
    }

    function showDbmsConsistencyState() {
        consistencyCheck(checkRes => TestUtils.showModuleSchema(checkRes));
    }

    function checkConsistency() {
        consistencyCheck(checkRes => TestUtils.showConsistencyCheckAlert(checkRes));
    }

    function postLogout() {
        document.querySelector('#logoutForm button').click();
    }

    function makeButton(clazz, name, callback, opts) {
        const button = makeEl('button');
        addClass(button, clazz);
        if (opts.tooltip) {
            const delegate = () => {
                $(button).attr('data-original-title', L10n.getValue(`header-${name}`));
            };
            L10n.onL10nChange(delegate);
            $(button).tooltip({
                title: L10n.getValue(`header-${name}`),
                placement: 'bottom'
            });
        }
        addClass(button, 'action-button');
        if (opts.className) {
            addClass(button, opts.className);
        }
        if (callback) {
            listen(button, 'click', callback);
        }
        return button;
    }

    function addBeforeUnloadListener() {
        window.onbeforeunload = (evt) => {
            makeBackup();
            const message = getL10n('utils-close-page-warning');
            if (typeof evt === 'undefined') {
                evt = window.event;
            }
            if (evt) {
                evt.returnValue = message;
            }
            return message;
        };
    }
    
    function readLocalBases() {
        if (!window.indexedDB) {
            Utils.alert(L10n.get('errors', 'indexeddb-is-not-found'));
            return Promise.resolve(null);
        }
        
        let counter = 0;
        let counters = [];
        while(!R.contains(counter, counters)) {
            counters.push(counter);
            counter = (counter + 1) % BACKUP_NUMBER;
        }
        
        return Promise.all(counters.map(counter => LocalBaseAPI.get('base' + counter))).then(bases => {
            bases = bases.filter(base => !R.isNil(base));
            if(bases.length === 0){
                return null;
            }
            
            bases.sort(CommonUtils.charOrdAFactory( base => -new Date(base.obj.Meta.saveTime).getTime()))
            return bases.map(R.prop('obj'));
        });
    }
    
    function localAutoSave() {
        if (!window.indexedDB) {
            return;
        }
        
        makeBackup();
        setInterval(makeBackup, BACKUP_INTERVAL); // 5 min
    }
    
    let counter = 0;
    function makeBackup() {
        console.log(counter + 1);
        counter = (counter + 1) % BACKUP_NUMBER;
        console.log('Starting autosave');
        
        DBMS.getDatabase((err, database) => {
            if (err) { Utils.handleError(err); return; }
            
            LocalBaseAPI.put('base' + counter, database).then(() => {
                console.log('Autosave OK ' + new Date());
//                LocalBaseAPI.get('base' + counter).then((database) => {
//                    console.log(database);
//                }).catch(Utils.handleError);
            }).catch(Utils.handleError);
        });
    }
    
})(this.PageManager = {});

/*Copyright 2015 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

/*global
 */

'use strict';

((exports, mode) => {
    const state = {};

    state.summary = {};

    if (mode === 'NIMS_Server' && PERMISSION_INFORMER_ENABLED) {
        exports.refresh = (callback) => {
            const request = $.ajax({
                url: '/getPermissionsSummary',
                dataType: 'text',
                method: 'GET',
                contentType: 'application/json;charset=utf-8',
                timeout: Constants.httpTimeout
            });

            request.done((data) => {
                state.summary = JSON.parse(data);
                if (callback) {
                    callback();
                } else {
                    exports.subscribe();
                }
                //        alert(data);
                //        alert(state.summary);
            });

            request.fail((errorInfo, textStatus, errorThrown) => {
                if (callback) {
                    callback(errorInfo.responseText || 'error');
                } else {
                    setTimeout(exports.subscribe, 500);
                }
            });
        };

        exports.subscribe = () => {
            const request = $.ajax({
                url: '/subscribeOnPermissionsUpdate',
                dataType: 'text',
                method: 'GET',
                contentType: 'application/json;charset=utf-8',
                timeout: Constants.httpTimeout
            });

            request.done((data) => {
                state.summary = JSON.parse(data);
                //        alert(data);
                //        alert(state.summary);
                exports.subscribe();
            });

            request.fail((errorInfo, textStatus, errorThrown) => {
                setTimeout(exports.subscribe, 500);
            });
        };

        exports.refresh();

        exports.isAdmin = (callback) => {
            callback(null, state.summary.isAdmin);
        };

        exports.isEditor = (callback) => {
            callback(null, state.summary.isEditor);
        };

        const isObjectEditableSync = (type, name) => {
            if (state.summary.isEditor) {
                return true;
            }
            if (state.summary.existEditor) {
                return false;
            }
            return state.summary.user[type].indexOf(name) !== -1;
        };

        exports.isEntityEditable = (type, entityName, callback) => {
            callback(null, isObjectEditableSync(type, entityName));
        };

        exports.getEntityNamesArray = R.curry((type, editableOnly, callback) => {
            const userEntities = state.summary.user[type];
            const allEntities = state.summary.all[type];
            const ownerMap = state.summary.ownerMaps[type];
            const names = allEntities.filter((name) => {
                if (editableOnly) {
                    return isObjectEditableSync(type, name);
                }
                return true;
            }).map(name => ({
                displayName: `${ownerMap[name]}. ${name}`,
                value: name,
                editable: isObjectEditableSync(type, name),
                isOwner: userEntities.indexOf(name) !== -1,
                hasOwner: ownerMap[name] !== '-'
            }));

            const name2str = a => a.displayName.toLowerCase();

            const entityCmp = CommonUtils.charOrdAFactoryBase('asc', (a, b) => {
                if (a.isOwner && b.isOwner) return name2str(a) > name2str(b);
                if (a.isOwner) return false;
                if (b.isOwner) return true;

                if (a.hasOwner && b.hasOwner) return name2str(a) > name2str(b);
                if (a.hasOwner) return false;
                if (b.hasOwner) return true;

                return name2str(a) > name2str(b);
            }, R.identity);

            //            names.sort(Utils.charOrdAObject);
            names.sort(entityCmp);

            callback(null, names);
        });

        exports.areAdaptationsEditable = (adaptations, callback) => {
            const map = {};
            const { isAdaptationRightsByStory } = state.summary;

            adaptations.forEach((elem) => {
                const key = `${elem.storyName}-${elem.characterName}`;
                if (isAdaptationRightsByStory) {
                    map[key] = isObjectEditableSync('story', elem.storyName);
                } else {
                    map[key] = isObjectEditableSync('character', elem.characterName);
                }
            });

            callback(null, map);
        };
    } else if (mode === 'Standalone') {
        exports.refresh = (callback) => {
            callback();
        };

        exports.isAdmin = (callback) => {
            callback(null, true);
        };

        exports.isEditor = (callback) => {
            callback(null, true);
        };

        exports.getEntityNamesArray = R.curry((type, editableOnly, callback) => {
            function processNames(err, names) {
                if (err) { Utils.handleError(err); return; }
                const newNames = [];
                names.forEach((name) => {
                    newNames.push({
                        displayName: name,
                        value: name,
                        editable: true
                    });
                });
                callback(null, newNames);
            }
            DBMS.getEntityNamesArray(type, processNames);
        });

        exports.isEntityEditable = (type, entityName, callback) => {
            callback(null, true);
        };

        exports.areAdaptationsEditable = (adaptations, callback) => {
            const map = {};
            adaptations.forEach((elem) => {
                map[`${elem.storyName}-${elem.characterName}`] = true;
            });

            callback(null, map);
        };
    }
})(this.PermissionInformer = {}, MODE);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpzL2RibXMvY2FsbE5vdGlmaWNhdG9yLmpzIiwianMvZGJtcy9sb2NhbERCTVMuanMiLCJqcy9kYm1zL3Byb21pc2lmaWNhdG9yLmpzIiwianMvZGJtcy9yZW1vdGVEQk1TLmpzIiwiLi4vY29yZS9qcy9maWxlVXRpbHMuanMiLCIuLi9jb3JlL2pzL2wxMG4uanMiLCIuLi9jb3JlL2pzL2xvY2FsQXV0b1NhdmUuanMiLCIuLi9jb3JlL2pzL3Rlc3RVdGlscy5qcyIsIi4uL2NvcmUvanMvdWlVdGlscy5qcyIsIi4uL2NvcmUvanMvdXRpbHMuanMiLCJqcy9wYWdlTWFuYWdlci5qcyIsImpzL3Blcm1pc3Npb25JbmZvcm1lci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoic2NyaXB0cy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKkNvcHlyaWdodCAyMDE4IFRpbW9mZXkgUmVjaGthbG92IDxudHNka0B5YW5kZXgucnU+LCBNYXJpYSBTaWRla2htZW5vdmEgPG1hdGlsZGFfQGxpc3QucnU+XHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuKChleHBvcnRzKSA9PiB7XHJcbiAgICBjb25zdCBzaG93Tm90aWZpY2F0aW9uID0gdHJ1ZTtcclxuICAgIGNvbnN0IG5vdGlmaWNhdGlvblRpbWVvdXQgPSAyMDAwO1xyXG4gICAgXHJcbiAgICBleHBvcnRzLm9uQ2FsbFN0YXJ0ID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghc2hvd05vdGlmaWNhdGlvbikgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkJveCA9IGNsZWFyRWwoZ2V0RWwoJ2RlYnVnTm90aWZpY2F0aW9uJykpO1xyXG4gICAgICAgIHJlbW92ZUNsYXNzKG5vdGlmaWNhdGlvbkJveCwgJ2hpZGRlbicpO1xyXG4gICAgICAgIHJlbW92ZUNsYXNzKG5vdGlmaWNhdGlvbkJveCwgJ29wZXJhdGlvbk9LJyk7XHJcbiAgICAgICAgcmVtb3ZlQ2xhc3Mobm90aWZpY2F0aW9uQm94LCAnb3BlcmF0aW9uRmFpbCcpO1xyXG4gICAgICAgIGFkZEVsKG5vdGlmaWNhdGlvbkJveCwgbWFrZVRleHQoTDEwbi5nZXQoJ2NvbnN0YW50JywgJ3NhdmluZycpKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHBvcnRzLm9uQ2FsbEZpbmlzaGVkID0gKGVycikgPT4ge1xyXG4gICAgICAgIGlmICghc2hvd05vdGlmaWNhdGlvbikgcmV0dXJuO1xyXG4gICAgICAgIGlmKGVycikge1xyXG4gICAgICAgICAgICBvbkNhbGxGYWlsKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb25DYWxsU3VjY2VzcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gb25DYWxsU3VjY2Vzcygpe1xyXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkJveCA9IGdldEVsKCdkZWJ1Z05vdGlmaWNhdGlvbicpO1xyXG4gICAgICAgIGFkZENsYXNzKG5vdGlmaWNhdGlvbkJveCwgJ29wZXJhdGlvbk9LJyk7XHJcbiAgICAgICAgYWRkRWwoY2xlYXJFbChub3RpZmljYXRpb25Cb3gpLCBtYWtlVGV4dChMMTBuLmdldCgnY29uc3RhbnQnLCAnc2F2aW5nLXN1Y2Nlc3MnKSkpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhub3RpZmljYXRpb25Cb3gsICdoaWRkZW4nKTtcclxuICAgICAgICB9LCBub3RpZmljYXRpb25UaW1lb3V0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkNhbGxGYWlsKCl7XHJcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uQm94ID0gZ2V0RWwoJ2RlYnVnTm90aWZpY2F0aW9uJyk7XHJcbiAgICAgICAgYWRkQ2xhc3Mobm90aWZpY2F0aW9uQm94LCAnb3BlcmF0aW9uRmFpbCcpO1xyXG4gICAgICAgIGFkZEVsKGNsZWFyRWwobm90aWZpY2F0aW9uQm94KSwgbWFrZVRleHQoTDEwbi5nZXQoJ2NvbnN0YW50JywgJ3NhdmluZy1mYWlsJykpKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgYWRkQ2xhc3Mobm90aWZpY2F0aW9uQm94LCAnaGlkZGVuJyk7XHJcbiAgICAgICAgfSwgbm90aWZpY2F0aW9uVGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG59KSh0aGlzLkNhbGxOb3RpZmljYXRvciA9IHt9KTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNSBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbi8qZ2xvYmFsXHJcbiBVdGlscywgRGF0YWJhc2UsIE1pZ3JhdG9yXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xyXG5cclxuZnVuY3Rpb24gbWFrZUxvY2FsREJNUyhmdWxsVmVyc2lvbikge1xyXG4vLyAgICBpZighZnVsbFZlcnNpb24pe1xyXG4vLyAgICAgICAgZnVuY3Rpb24gTG9jYWxEQk1TKCl7XHJcbi8vICAgICAgICB9O1xyXG4vLyAgICAgICAgcmV0dXJuIExvY2FsREJNUztcclxuLy8gICAgfVxyXG4gICAgY29uc3QgbGlzdGVuZXJzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxpc3RlbmVyc1tldmVudE5hbWVdID0gbGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XHJcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IHtcclxuICAgICAgICBNaWdyYXRvcixcclxuICAgICAgICBDb21tb25VdGlscyxcclxuICAgICAgICBDVTogQ29tbW9uVXRpbHMsXHJcbiAgICAgICAgUHJvamVjdFV0aWxzLFxyXG4gICAgICAgIFBVOiBQcm9qZWN0VXRpbHMsXHJcbiAgICAgICAgUHJlY29uZGl0aW9uLFxyXG4gICAgICAgIFBDOiBQcmVjb25kaXRpb24sXHJcbiAgICAgICAgRXZlbnRFbWl0dGVyLFxyXG4gICAgICAgIFIsXHJcbiAgICAgICAgQWp2LFxyXG4gICAgICAgIFNjaGVtYSxcclxuICAgICAgICBFcnJvcnMsXHJcbiAgICAgICAgYWRkTGlzdGVuZXIsXHJcbiAgICAgICAgQ29uc3RhbnRzLFxyXG4gICAgICAgIGRibXNVdGlsczoge30sXHJcbiAgICAgICAgZGF0ZUZvcm1hdCxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gTG9jYWxEQk1TKCkge1xyXG4gICAgICAgIHRoaXMuX2luaXQobGlzdGVuZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICBMb2NhbERCTVMucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuU2V0dGluZ3M7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGZ1bmNMaXN0ID0ge307XHJcbiAgICBjb25zdCBmdW5jID0gUi5jdXJyeSgobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IFIua2V5cyhMb2NhbERCTVMucHJvdG90eXBlKTtcclxuICAgICAgICB3aW5kb3dbbmFtZV0oTG9jYWxEQk1TLCBvcHRzKTtcclxuICAgICAgICBjb25zdCBhZnRlciA9IFIua2V5cyhMb2NhbERCTVMucHJvdG90eXBlKTtcclxuICAgICAgICBjb25zdCBkaWZmID0gUi5kaWZmZXJlbmNlKGFmdGVyLCBiZWZvcmUpO1xyXG4gICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhgJHtuYW1lfSAke2RpZmZ9YCk7XHJcbiAgICAgICAgZnVuY0xpc3RbbmFtZV0gPSBSLnppcE9iaihkaWZmLCBSLnJlcGVhdCh0cnVlLCBkaWZmLmxlbmd0aCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgWydiYXNlQVBJJyxcclxuICAgICAgICAnY29uc2lzdGVuY3lDaGVja0FQSScsXHJcbiAgICAgICAgJ3N0YXRpc3RpY3NBUEknLFxyXG4gICAgICAgICdwcm9maWxlc0FQSScsXHJcbiAgICAgICAgJ3Byb2ZpbGVCaW5kaW5nQVBJJyxcclxuXHJcbiAgICAgICAgJ3Byb2ZpbGVWaWV3QVBJJyxcclxuXHJcbiAgICAgICAgJ2dyb3Vwc0FQSScsXHJcbiAgICAgICAgJ2dyb3VwU2NoZW1hQVBJJyxcclxuICAgICAgICAncmVsYXRpb25zQVBJJyxcclxuICAgICAgICAnYnJpZWZpbmdFeHBvcnRBUEknLFxyXG5cclxuICAgICAgICAncHJvZmlsZUNvbmZpZ3VyZXJBUEknLFxyXG4gICAgICAgICdlbnRpdHlBUEknLFxyXG4gICAgICAgICdzdG9yeUJhc2VBUEknLFxyXG4gICAgICAgICdzdG9yeUV2ZW50c0FQSScsXHJcbiAgICAgICAgJ3N0b3J5Q2hhcmFjdGVyc0FQSScsXHJcblxyXG4gICAgICAgICdzdG9yeVZpZXdBUEknLFxyXG4gICAgICAgICdzdG9yeUFkYXB0YXRpb25zQVBJJyxcclxuICAgICAgICAnYWNjZXNzTWFuYWdlckFQSScsXHJcbiAgICAgICAgJ3RleHRTZWFyY2hBUEknLFxyXG4gICAgICAgICdnZWFyc0FQSScsXHJcbiAgICAgICAgJ3NsaWRlcnNBUEknLFxyXG4gICAgICAgICdsb2dBUEknXS5tYXAoZnVuYyk7XHJcblxyXG4gICAgTG9nZ2VyLmF0dGFjaExvZ0NhbGxzKExvY2FsREJNUywgUiwgZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGJhc2VBUElMaXN0ID0gUi5rZXlzKFIubWVyZ2VBbGwoUi52YWx1ZXMoZnVuY0xpc3QpKSk7XHJcbiAgICBjb25zdCBsb2dnZXJBUElMaXN0ID0gUi5kaWZmZXJlbmNlKFIua2V5cyhSLm1lcmdlQWxsKFIudmFsdWVzKExvZ2dlci5hcGlJbmZvKSkpLCBMb2dnZXIub2ZmbGluZUlnbm9yZUxpc3QpO1xyXG5cclxuICAgIGNvbnN0IGxvZ2dlckRpZmYgPSBSLnN5bW1ldHJpY0RpZmZlcmVuY2UobG9nZ2VyQVBJTGlzdCwgYmFzZUFQSUxpc3QpO1xyXG4gICAgaWYgKGxvZ2dlckRpZmYubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYExvZ2dlciBkaWZmOiAke2xvZ2dlckRpZmZ9YCk7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgTG9nZ2VkIGJ1dCBub3QgaW4gYmFzZTogJHtSLmRpZmZlcmVuY2UobG9nZ2VyQVBJTGlzdCwgYmFzZUFQSUxpc3QpfWApO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEluIGJhc2UgYnV0IG5vdCBsb2dnZWQ6ICR7Ui5kaWZmZXJlbmNlKGJhc2VBUElMaXN0LCBsb2dnZXJBUElMaXN0KX1gKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSBwcm9jZXNzb3JzIGFyZSBpbmNvbnNpc3RlbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTG9jYWxEQk1TO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlTG9jYWxEQk1TV3JhcHBlcihkYm1zKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gTG9jYWxEQk1TV3JhcHBlcihkYm1zKSB7XHJcbiAgICAgICAgdGhpcy5kYm1zID0gZGJtcztcclxuICAgICAgICB0aGlzLmNsZWFyU2V0dGluZ3MoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgT2JqZWN0LmtleXMoZGJtcy5fX3Byb3RvX18pLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBMb2NhbERCTVNXcmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKENvbW1vblV0aWxzLnN0YXJ0c1dpdGgobmFtZSwgJ2dldCcpIHx8IENvbW1vblV0aWxzLnN0YXJ0c1dpdGgobmFtZSwgJ2lzJykgfHwgUi5lcXVhbHMobmFtZSwgJ2xvZycpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRibXNbbmFtZV0uYXBwbHkodGhpcy5kYm1zLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBDYWxsTm90aWZpY2F0b3Iub25DYWxsU3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2FsbE5vdGlmaWNhdG9yLm9uQ2FsbEZpbmlzaGVkKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYm1zW25hbWVdLmFwcGx5KHRoaXMuZGJtcywgYXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgUHJvbWlzaWZpY2F0b3IucHJvbWlzaWZ5KGRibXMsIExvY2FsREJNU1dyYXBwZXIpO1xyXG5cclxuICAgIExvY2FsREJNU1dyYXBwZXIucHJvdG90eXBlLmNsZWFyU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5TZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgQnJpZWZpbmdQcmV2aWV3OiB7fSxcclxuICAgICAgICAgICAgU3Rvcmllczoge30sXHJcbiAgICAgICAgICAgIFByb2ZpbGVFZGl0b3I6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxEQk1TV3JhcHBlci5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuU2V0dGluZ3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG5ldyBMb2NhbERCTVNXcmFwcGVyKGRibXMpO1xyXG59IiwiLypDb3B5cmlnaHQgMjAxOCBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgZXhwb3J0cy5wcm9taXNpZnkgPSAoc3JjLCBkc3QpID0+IHtcclxuICAgICAgICBPYmplY3Qua2V5cyhzcmMuX19wcm90b19fKS5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGRzdC5wcm90b3R5cGVbbmFtZSArICdQbSddID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vblV0aWxzLnN0YXJ0c1dpdGgobmFtZSwgJ2dldCcpIHx8IENvbW1vblV0aWxzLnN0YXJ0c1dpdGgobmFtZSwgJ2lzJykgfHwgUi5lcXVhbHMobmFtZSwgJ2xvZycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChmdW5jdGlvbihlcnIsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlcnIpIHtyZWplY3QoZXJyKTsgcmV0dXJuO31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYm1zW25hbWVdLmFwcGx5KHRoaXMuZGJtcywgYXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBDYWxsTm90aWZpY2F0b3Iub25DYWxsU3RhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxOb3RpZmljYXRvci5vbkNhbGxGaW5pc2hlZChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlcnIpIHtyZWplY3QoZXJyKTsgcmV0dXJuO31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGJtc1tuYW1lXS5hcHBseSh0aGlzLmRibXMsIGFycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxufSkodGhpcy5Qcm9taXNpZmljYXRvciA9IHt9KTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNSBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbi8qZ2xvYmFsXHJcbiBVdGlscywgRGF0YWJhc2VcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzLHByZWZlci1yZXN0LXBhcmFtcyAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIG1ha2VSZW1vdGVEQk1TKExvY2FsREJNUykge1xyXG4gICAgY29uc3Qgc2hvd05vdGlmaWNhdGlvbiA9IHRydWU7XHJcbiAgICBjb25zdCBub3RpZmljYXRpb25UaW1lb3V0ID0gMjAwMDtcclxuICAgIC8vY29uc3Qgbm90aWZpY2F0aW9uVGltZW91dCA9IDEwMDAwO1xyXG4gICAgY29uc3QgdXJsID0gJy8nO1xyXG5cclxuICAgIGZ1bmN0aW9uIFJlbW90ZURCTVMoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhclNldHRpbmdzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVtb3RlREJNUy5fc2ltcGxlR2V0ID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgcGFyYW1TdHIgPSAnJztcclxuICAgICAgICBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHBhcmFtU3RyID0gYD9wYXJhbXM9JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocGFyYW1zKSl9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB1cmw6IHVybCArIG5hbWUgKyBwYXJhbVN0cixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IENvbnN0YW50cy5odHRwVGltZW91dCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5kb25lKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEpTT04ucGFyc2UoZGF0YSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXF1ZXN0LmZhaWwoKGVycm9ySW5mbywgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKEpTT04ucGFyc2UoZXJyb3JJbmZvLnJlc3BvbnNlVGV4dCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9ySW5mby5yZXNwb25zZVRleHQgfHwgdGV4dFN0YXR1cyB8fCAnZXJyb3InKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZW1vdGVEQk1TLl9zaW1wbGVQdXQgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdXJsOiB1cmwgKyBuYW1lLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcsXHJcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgICAgICAgICB0aW1lb3V0OiBDb25zdGFudHMuaHR0cFRpbWVvdXRcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBDYWxsTm90aWZpY2F0b3Iub25DYWxsU3RhcnQoKTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5kb25lKChkYXRhMikgPT4ge1xyXG4gICAgICAgICAgICBDYWxsTm90aWZpY2F0b3Iub25DYWxsRmluaXNoZWQoKTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXF1ZXN0LmZhaWwoKGVycm9ySW5mbywgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcclxuICAgICAgICAgICAgQ2FsbE5vdGlmaWNhdG9yLm9uQ2FsbEZpbmlzaGVkKGVycm9ySW5mbyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhKU09OLnBhcnNlKGVycm9ySW5mby5yZXNwb25zZVRleHQpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvckluZm8ucmVzcG9uc2VUZXh0IHx8IHRleHRTdGF0dXMgfHwgJ2Vycm9yJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIE9iamVjdC5rZXlzKExvY2FsREJNUy5wcm90b3R5cGUpLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBSZW1vdGVEQk1TLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGlmKENvbW1vblV0aWxzLnN0YXJ0c1dpdGgobmFtZSwgXCJfXCIpKXtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBmb3IgaW5uZXIgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGlmIChDb21tb25VdGlscy5zdGFydHNXaXRoKG5hbWUsICdnZXQnKSB8fCBDb21tb25VdGlscy5zdGFydHNXaXRoKG5hbWUsICdpcycpKSB7XHJcbiAgICAgICAgICAgICAgICBSZW1vdGVEQk1TLl9zaW1wbGVHZXQobmFtZSwgYXJyLCBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFJlbW90ZURCTVMuX3NpbXBsZVB1dChuYW1lLCBhcnIsIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBwcm9taXNpZmljYXRpb25cclxuICAgIE9iamVjdC5rZXlzKExvY2FsREJNUy5wcm90b3R5cGUpLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBSZW1vdGVEQk1TLnByb3RvdHlwZVtuYW1lICsgJ1BtJ10gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGlmKENvbW1vblV0aWxzLnN0YXJ0c1dpdGgobmFtZSwgXCJfXCIpKXtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBmb3IgaW5uZXIgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChDb21tb25VdGlscy5zdGFydHNXaXRoKG5hbWUsICdnZXQnKSB8fCBDb21tb25VdGlscy5zdGFydHNXaXRoKG5hbWUsICdpcycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVtb3RlREJNUy5fc2ltcGxlR2V0KG5hbWUsIGFyciwgZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlcnIpIHtyZWplY3QoZXJyKTsgcmV0dXJuO31cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIFJlbW90ZURCTVMuX3NpbXBsZVB1dChuYW1lLCBhcnIsIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXJyKSB7cmVqZWN0KGVycik7IHJldHVybjt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgUmVtb3RlREJNUy5wcm90b3R5cGUuY2xlYXJTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLlNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBCcmllZmluZ1ByZXZpZXc6IHt9LFxyXG4gICAgICAgICAgICBTdG9yaWVzOiB7fSxcclxuICAgICAgICAgICAgUHJvZmlsZUVkaXRvcjoge31cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBSZW1vdGVEQk1TLnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5TZXR0aW5ncztcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVtb3RlREJNUztcclxufVxyXG4iLCIvKkNvcHlyaWdodCAyMDE1LTIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT4sIE1hcmlhIFNpZGVraG1lbm92YSA8bWF0aWxkYV9AbGlzdC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4oKGV4cG9ydHMpID0+IHtcclxuICAgIGV4cG9ydHMubWFrZU5ld0Jhc2UgPSAoY2FsbGJhY2spID0+ICgpID0+IHtcclxuICAgICAgICBVdGlscy5jb25maXJtKGdldEwxMG4oJ3V0aWxzLW5ldy1iYXNlLXdhcm5pbmcnKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBEQk1TLnNldERhdGFiYXNlKENvbW1vblV0aWxzLmNsb25lKEVtcHR5QmFzZS5kYXRhKSwgY2FsbGJhY2spO1xyXG4vLyAgICAgICAgICAgIFRlc3RVdGlscy5hZGRHcm91cFRlc3RpbmdEYXRhKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMub3BlbkhlbHAgPSAoKSA9PiB7XHJcbiAgICAgICAgd2luZG93Lm9wZW4oJ2V4dHJhcy9kb2Mvbmltcy5odG1sJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMucmVhZFNpbmdsZUZpbGUgPSAoY2FsbGJhY2spID0+IChldnQpID0+IHtcclxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgZmlyc3QgKGFuZCBvbmx5ISkgRmlsZSBmcm9tIHRoZSBGaWxlTGlzdCBvYmplY3RcclxuICAgICAgICBjb25zdCBmID0gZXZ0LnRhcmdldC5maWxlc1swXTtcclxuXHJcbiAgICAgICAgaWYgKGYpIHtcclxuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgIHIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gZS50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IEpTT04ucGFyc2UoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIERCTVMuc2V0RGF0YWJhc2UoZGF0YWJhc2UsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHIucmVhZEFzVGV4dChmKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBVdGlscy5hbGVydChnZXRMMTBuKCd1dGlscy1iYXNlLWZpbGUtbG9hZGluZy1lcnJvcicpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuc2F2ZUZpbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgREJNUy5nZXREYXRhYmFzZSgoZXJyLCBkYXRhYmFzZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICBleHBvcnRzLmpzb24yRmlsZShkYXRhYmFzZSwgZXhwb3J0cy5tYWtlRmlsZU5hbWUoYCR7QkFTRV9GSUxFX05BTUV9XyR7ZGF0YWJhc2UuTWV0YS5uYW1lfWAsICdqc29uJywgbmV3IERhdGUoZGF0YWJhc2UuTWV0YS5zYXZlVGltZSkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4cG9ydHMubWFrZUZpbGVOYW1lID0gKHJvb3QsIGV4dGVuc2lvbiwgZGF0ZSkgPT4ge1xyXG4gICAgICAgIGRhdGUgPSBkYXRlIHx8IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc3QgdGltZVN0ciA9IGRhdGUuZm9ybWF0KCdkZC1tbW0teXl5eV9ISC1NTS1zcycpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7cm9vdH1fJHt0aW1lU3RyfWA7XHJcbiAgICAgICAgcmV0dXJuIGAke0NvbW1vblV0aWxzLnNhbml0aXplU3RyMkZpbGVOYW1lKGZpbGVOYW1lKX0uJHtleHRlbnNpb259YDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5qc29uMkZpbGUgPSAoc3RyLCBmaWxlTmFtZSkgPT4ge1xyXG4gICAgICAgIGV4cG9ydHMuc3RyMkZpbGUoSlNPTi5zdHJpbmdpZnkoc3RyLCBudWxsLCAnICAnKSwgZmlsZU5hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLnN0cjJGaWxlID0gKHN0ciwgZmlsZU5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3N0cl0sIHtcclxuICAgICAgICAgICAgdHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD11dGYtOCdcclxuICAgICAgICB9KTtcclxuICAgICAgICBzYXZlQXMoYmxvYiwgZmlsZU5hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzQ3N2U3RyKHN0cikge1xyXG4gICAgICAgIGlmICghKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0ci5yZXBsYWNlKC9cIi9nLCAnXCJcIicpO1xyXG4gICAgICAgIGlmIChyZXN1bHQuc2VhcmNoKC8oXCJ8LHxcXG4pL2cpID49IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gYFwiJHtyZXN1bHR9XCJgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydHMuYXJyMmQyQ3N2ID0gKGFyciwgZmlsZU5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBjc3YgPSBgXFx1ZmVmZiR7YXJyLm1hcChkYXRhQXJyYXkgPT4gZGF0YUFycmF5Lm1hcChwcmVwcm9jZXNzQ3N2U3RyKS5qb2luKCc7JykpLmpvaW4oJ1xcbicpfWA7XHJcblxyXG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBCbG9iKFtjc3ZdLCB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OydcclxuICAgICAgICB9KTtcclxuICAgICAgICBzYXZlQXMob3V0LCBleHBvcnRzLm1ha2VGaWxlTmFtZShmaWxlTmFtZSwgJ2NzdicpKTtcclxuICAgIH07XHJcbn0pKHRoaXMuRmlsZVV0aWxzID0ge30pO1xyXG4iLCIvKkNvcHlyaWdodCAyMDE1LTIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT4sIE1hcmlhIFNpZGVraG1lbm92YSA8bWF0aWxkYV9AbGlzdC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIsdmFycy1vbi10b3AgKi9cclxuXHJcbigoZXhwb3J0cywgRGljdGlvbmFyaWVzKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHt9O1xyXG5cclxuICAgIHN0YXRlLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICBzdGF0ZS5sMTBuRGVsZWdhdGVzID0gW107XHJcbiAgICBzdGF0ZS5kaWN0aW9uYXJpZXMgPSB7fTtcclxuICAgIHN0YXRlLmxhbmcgPSBkZWZhdWx0TGFuZztcclxuICAgIHN0YXRlLmZvdW5kU3RhdGlzdGljcyA9IHt9O1xyXG4gICAgc3RhdGUubm90Rm91bmRTdGF0aXN0aWNzID0ge307XHJcblxyXG4gICAgZXhwb3J0cy5pbml0ID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0ZS5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhuYXZpZ2F0b3IubGFuZ3VhZ2UpO1xyXG5cclxuICAgICAgICBzdGF0ZS5kaWN0aW9uYXJpZXMgPSBSLm1hcChwcm9jZXNzRGljdGlvbmFyeSwgRGljdGlvbmFyaWVzKTtcclxuICAgICAgICBcclxuICAgICAgICBkaWN0SXRlcmF0b3IoY2hlY2tEaWN0aW9uYXJ5Q29tcGxldGVuZXNzKTtcclxuICAgICAgICBkaWN0SXRlcmF0b3IoY2hlY2tEaWN0aW9uYXJ5SW5zZXJ0Q291bnQpO1xyXG4gICAgICAgIHNob3dEdXBsaWNhdGVzKCk7XHJcblxyXG4gICAgICAgIC8vICAgIHZhciBsYW5nID0gKG5hdmlnYXRvci5sYW5ndWFnZXMgPyBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIDogbmF2aWdhdG9yLmJyb3dzZXJMYW5ndWFnZSkuc3BsaXQoJy0nKVswXTtcclxuICAgICAgICAvLyAgICB2YXIgbGFuZyA9ICdydSc7XHJcbiAgICAgICAgLy8gICAgICAgIHZhciBsYW5nID0gZGVmYXVsdExhbmc7XHJcbiAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKGxhbmcpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUuZGljdGlvbmFyaWVzW2RlZmF1bHRMYW5nXSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5kaWN0ID0gc3RhdGUuZGljdGlvbmFyaWVzW2RlZmF1bHRMYW5nXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0ZS5kaWN0ID0gc3RhdGUuZGljdGlvbmFyaWVzLmVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRIdG1sTGFuZyhkZWZhdWx0TGFuZyk7XHJcbiAgICAgICAgZXhwb3J0cy5vbkwxMG5DaGFuZ2UoZXhwb3J0cy5sb2NhbGl6ZVN0YXRpYyk7XHJcbiAgICAgICAgc3RhdGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZGljdEl0ZXJhdG9yKGNhbGxiYWNrKXtcclxuICAgICAgICBjb25zdCBkaWN0TmFtZXMgPSBSLmtleXMoc3RhdGUuZGljdGlvbmFyaWVzKTtcclxuICAgICAgICBpZihkaWN0TmFtZXMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJhc2UgPSBSLmhlYWQoZGljdE5hbWVzKTtcclxuICAgICAgICBSLnRhaWwoZGljdE5hbWVzKS5mb3JFYWNoKCBkaWN0TmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGJhc2UsIGRpY3ROYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2hlY2tEaWN0aW9uYXJ5Q29tcGxldGVuZXNzKGJhc2UsIGRpY3ROYW1lKXtcclxuICAgICAgICBjb25zdCBiYXNlVG9EaWN0ID0gUi5kaWZmZXJlbmNlKFIua2V5cyhzdGF0ZS5kaWN0aW9uYXJpZXNbYmFzZV0pLCBSLmtleXMoc3RhdGUuZGljdGlvbmFyaWVzW2RpY3ROYW1lXSkpO1xyXG4gICAgICAgIGlmKGJhc2VUb0RpY3QubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMMTBOOiAke2Jhc2V9IHRvICR7ZGljdE5hbWV9IGRpZmZlcmVuY2UgaXMgbm90IGVtcHR5IGAsIGJhc2VUb0RpY3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMMTBOOiAke2Jhc2V9IHRvICR7ZGljdE5hbWV9IGRpZmZlcmVuY2UgaXMgZW1wdHkgKE9LKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaWN0VG9CYXNlID0gUi5kaWZmZXJlbmNlKFIua2V5cyhzdGF0ZS5kaWN0aW9uYXJpZXNbZGljdE5hbWVdKSwgUi5rZXlzKHN0YXRlLmRpY3Rpb25hcmllc1tiYXNlXSkpO1xyXG4gICAgICAgIGlmKGRpY3RUb0Jhc2UubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMMTBOOiAke2RpY3ROYW1lfSB0byAke2Jhc2V9IGRpZmZlcmVuY2UgaXMgbm90IGVtcHR5IGAsIGRpY3RUb0Jhc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMMTBOOiAke2RpY3ROYW1lfSB0byAke2Jhc2V9IGRpZmZlcmVuY2UgaXMgZW1wdHkgKE9LKWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2hlY2tEaWN0aW9uYXJ5SW5zZXJ0Q291bnQoYmFzZSwgZGljdE5hbWUpe1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbnN0ID0gc3RhdGUuZGljdGlvbmFyaWVzW2Jhc2VdO1xyXG4gICAgICAgIGNvbnN0IGRpY3RJbnN0ID0gc3RhdGUuZGljdGlvbmFyaWVzW2RpY3ROYW1lXTtcclxuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBSLmludGVyc2VjdGlvbihSLmtleXMoYmFzZUluc3QpLCBSLmtleXMoc3RhdGUuZGljdGlvbmFyaWVzW2RpY3ROYW1lXSkpO1xyXG4gICAgICAgIGNvbnN0IG5vdEVxdWFsID0gaW50ZXJzZWN0aW9uLmZpbHRlcihrZXkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29tbW9uVXRpbHMuc3RyRm9ybWF0SW5zZXJ0c0NvdW50KGJhc2VJbnN0W2tleV0pICE9PSBDb21tb25VdGlscy5zdHJGb3JtYXRJbnNlcnRzQ291bnQoZGljdEluc3Rba2V5XSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZihub3RFcXVhbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMMTBOOiBpbnNlcnQgY291bnRzIGZvciAke2RpY3ROYW1lfSBhbmQgJHtiYXNlfSBhcmUgbm90IGVxdWFsYCwgbm90RXF1YWwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMMTBOOiBpbnNlcnQgY291bnRzIGZvciAke2RpY3ROYW1lfSBhbmQgJHtiYXNlfSBhcmUgZXF1YWwgKE9LKWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gc2hvd0R1cGxpY2F0ZXMoKXtcclxuICAgICAgICBSLmtleXMoc3RhdGUuZGljdGlvbmFyaWVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IFIuZmlsdGVyKGFyciA9PiBhcnIubGVuZ3RoID4gMSwgUi5pbnZlcnQoc3RhdGUuZGljdGlvbmFyaWVzW2tleV0pKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEwxME46IER1cGxpY2F0ZXMgJHtrZXl9IGAsIG1hcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb2Nlc3NEaWN0aW9uYXJ5ID0gKGRpY3Rpb25hcnkpID0+IHtcclxuICAgICAgICBjb25zdCBwcm9jZXNzZWREaWN0aW9uYXJ5ID0ge307XHJcbiAgICAgICAgUi50b1BhaXJzKGRpY3Rpb25hcnkpLmZvckVhY2goKFtzZWN0aW9uTmFtZSwgc2VjdGlvbl0pID0+IHtcclxuICAgICAgICAgICAgUi50b1BhaXJzKHNlY3Rpb24pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGljdGlvbmFyeVtgJHtzZWN0aW9uTmFtZX0tJHtrZXl9YF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbk5hbWUgaW4gZGljdGlvbmFyeSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRpY3Rpb25hcnlbc2VjdGlvbk5hbWVdKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGljdGlvbmFyeVtgJHtzZWN0aW9uTmFtZX0tJHtuYW1lfWBdID0gZGljdGlvbmFyeVtzZWN0aW9uTmFtZV1bbmFtZV07XHJcbiAgICAgICAgLy8gICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGljdGlvbmFyeTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHNldEh0bWxMYW5nID0gbGFuZyA9PiBzZXRBdHRyKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0sICdsYW5nJywgbGFuZyk7XHJcbiAgICBcclxuICAgIGV4cG9ydHMuZ2V0TG9jYWxlID0gKCkgPT4gc3RhdGUubGFuZztcclxuXHJcbiAgICBleHBvcnRzLnRvZ2dsZUwxMG4gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmxhbmcgPT09ICdydScpIHtcclxuICAgICAgICAgICAgc3RhdGUuZGljdCA9IHN0YXRlLmRpY3Rpb25hcmllcy5lbjtcclxuICAgICAgICAgICAgc3RhdGUubGFuZyA9ICdlbic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdGUuZGljdCA9IHN0YXRlLmRpY3Rpb25hcmllcy5ydTtcclxuICAgICAgICAgICAgc3RhdGUubGFuZyA9ICdydSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmZvdW5kU3RhdGlzdGljcy5jbGVhcigpO1xyXG4gICAgICAgIHN0YXRlLm5vdEZvdW5kU3RhdGlzdGljcy5jbGVhcigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNldEh0bWxMYW5nKHN0YXRlLmxhbmcpO1xyXG4gICAgICAgIHN0YXRlLmwxMG5EZWxlZ2F0ZXMuZm9yRWFjaCgoZGVsZWdhdGUpID0+IHtcclxuICAgICAgICAgICAgZGVsZWdhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5nZXRMYW5nID0gKCkgPT4gc3RhdGUubGFuZy50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIGV4cG9ydHMuZm9ybWF0ID0gUi5jdXJyeSgobmFtZXNwYWNlLCBuYW1lLCBhcmdzKSA9PiBzdHJGb3JtYXQoZXhwb3J0cy5nZXQobmFtZXNwYWNlLCBuYW1lKSwgYXJncykpO1xyXG5cclxuICAgIGV4cG9ydHMuZ2V0ID0gUi5jdXJyeSgobmFtZXNwYWNlLCBuYW1lKSA9PiBMMTBuLmdldFZhbHVlKGAke25hbWVzcGFjZX0tJHtuYW1lfWApKTtcclxuXHJcbiAgICBleHBvcnRzLmdldFZhbHVlID0gKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXRlLmRpY3RbbmFtZV07XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFZhbHVlIGlzIG5vdCBmb3VuZDogJHtuYW1lfWApO1xyXG4gICAgICAgICAgICBzdGF0ZS5ub3RGb3VuZFN0YXRpc3RpY3NbbmFtZV0gPSAoc3RhdGUubm90Rm91bmRTdGF0aXN0aWNzW25hbWVdIHx8IDApICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0ZS5mb3VuZFN0YXRpc3RpY3NbbmFtZV0gPSAoc3RhdGUuZm91bmRTdGF0aXN0aWNzW25hbWVdIHx8IDApICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IGAke25hbWV9OlJBIFJBLUFILUFILUFIIFJPTUEgUk9NQS1NQSBHQUdBIE9IIExBLUxBYDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4cG9ydHMuaGFzVmFsdWUgPSAobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RhdGUuZGljdFtuYW1lXTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5vbkwxMG5DaGFuZ2UgPSAoZGVsZWdhdGUpID0+IHtcclxuICAgICAgICBzdGF0ZS5sMTBuRGVsZWdhdGVzLnB1c2goZGVsZWdhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmxvY2FsaXplU3RhdGljID0gKGVsKSA9PiB7XHJcbiAgICAgICAgZWwgPSBlbCB8fCBkb2N1bWVudDtcclxuICAgICAgICBubDJhcnJheShxZWVzKGVsLCAnW2wxMG4taWRdJykpLm1hcChlbDIgPT5cclxuICAgICAgICAgICAgYWRkRWwoY2xlYXJFbChlbDIpLCBtYWtlVGV4dChleHBvcnRzLmdldFZhbHVlKGdldEF0dHIoZWwyLCAnbDEwbi1pZCcpKSkpKTtcclxuICAgICAgICBubDJhcnJheShxZWVzKGVsLCAnW2wxMG4tcGxhY2Vob2xkZXItaWRdJykpLm1hcChlbDIgPT5cclxuICAgICAgICAgICAgc2V0QXR0cihlbDIsICdwbGFjZWhvbGRlcicsIGV4cG9ydHMuZ2V0VmFsdWUoZ2V0QXR0cihlbDIsICdsMTBuLXBsYWNlaG9sZGVyLWlkJykpKSk7XHJcbiAgICAgICAgbmwyYXJyYXkocWVlcyhlbCwgJ1tsMTBuLXRpdGxlXScpKS5tYXAoZWwyID0+XHJcbiAgICAgICAgICAgIHNldEF0dHIoZWwyLCAndGl0bGUnLCBleHBvcnRzLmdldFZhbHVlKGdldEF0dHIoZWwyLCAnbDEwbi10aXRsZScpKSkpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5nZXRGb3VuZFN0YXRpc3RpY3MgPSAoKSA9PiBSLmNsb25lKHN0YXRlLmZvdW5kU3RhdGlzdGljcyk7XHJcbiAgICBleHBvcnRzLmdldE5vdEZvdW5kU3RhdGlzdGljcyA9ICgpID0+IFIuY2xvbmUoc3RhdGUubm90Rm91bmRTdGF0aXN0aWNzKTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5nZXROb3RVc2VkQnlTdGF0aXN0aWNzID0gKCkgPT4gUi5kaWZmZXJlbmNlKFIua2V5cyhzdGF0ZS5kaWN0KSwgUi5rZXlzKHN0YXRlLmZvdW5kU3RhdGlzdGljcykpO1xyXG4gICAgXHJcbn0pKHRoaXMuTDEwbiA9IHt9LCBEaWN0aW9uYXJpZXMpO1xyXG4iLCIvKkNvcHlyaWdodCAyMDE4IFRpbW9mZXkgUmVjaGthbG92IDxudHNka0B5YW5kZXgucnU+LCBNYXJpYSBTaWRla2htZW5vdmEgPG1hdGlsZGFfQGxpc3QucnU+XHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuKChleHBvcnRzKSA9PiB7XHJcbiAgICBjb25zdCBpbmRleGVkREIgICAgID0gd2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cubW96SW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCO1xyXG4gICAgY29uc3QgSURCVHJhbnNhY3Rpb24gID0gd2luZG93LklEQlRyYW5zYWN0aW9uIHx8IHdpbmRvdy53ZWJraXRJREJUcmFuc2FjdGlvbiB8fCB3aW5kb3cubXNJREJUcmFuc2FjdGlvbjtcclxuICAgIGNvbnN0IGJhc2VOYW1lICAgICAgPSBcImZpbGVzQmFzZVwiO1xyXG4gICAgY29uc3Qgc3RvcmVOYW1lICAgICA9IFwiZmlsZXNTdG9yZVwiO1xyXG4gICAgXHJcbi8vIC8vIFRoaXMgd29ya3Mgb24gYWxsIGRldmljZXMvYnJvd3NlcnMsIGFuZCB1c2VzIEluZGV4ZWREQlNoaW0gYXMgYSBmaW5hbCBmYWxsYmFjayBcclxuLy8gICAgdmFyIGluZGV4ZWREQiA9IHdpbmRvdy5pbmRleGVkREIgfHwgd2luZG93Lm1vekluZGV4ZWREQiB8fCB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8IHdpbmRvdy5tc0luZGV4ZWREQiB8fCB3aW5kb3cuc2hpbUluZGV4ZWREQjtcclxuLy9cclxuLy8gICAgLy8gT3BlbiAob3IgY3JlYXRlKSB0aGUgZGF0YWJhc2VcclxuLy8gICAgdmFyIG9wZW4gPSBpbmRleGVkREIub3BlbihcIk15RGF0YWJhc2VcIiwgMSk7XHJcbi8vXHJcbi8vICAgIC8vIENyZWF0ZSB0aGUgc2NoZW1hXHJcbi8vICAgIG9wZW4ub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24oKSB7XHJcbi8vICAgICAgICB2YXIgZGIgPSBvcGVuLnJlc3VsdDtcclxuLy8gICAgICAgIHZhciBzdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFwiTXlPYmplY3RTdG9yZVwiLCB7a2V5UGF0aDogXCJpZFwifSk7XHJcbi8vICAgICAgICB2YXIgaW5kZXggPSBzdG9yZS5jcmVhdGVJbmRleChcIk5hbWVJbmRleFwiLCBbXCJuYW1lLmxhc3RcIiwgXCJuYW1lLmZpcnN0XCJdKTtcclxuLy8gICAgfTtcclxuLy9cclxuLy8gICAgb3Blbi5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcclxuLy8gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHRyYW5zYWN0aW9uXHJcbi8vICAgICAgICB2YXIgZGIgPSBvcGVuLnJlc3VsdDtcclxuLy8gICAgICAgIHZhciB0eCA9IGRiLnRyYW5zYWN0aW9uKFwiTXlPYmplY3RTdG9yZVwiLCBcInJlYWR3cml0ZVwiKTtcclxuLy8gICAgICAgIHZhciBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFwiTXlPYmplY3RTdG9yZVwiKTtcclxuLy8gICAgICAgIHZhciBpbmRleCA9IHN0b3JlLmluZGV4KFwiTmFtZUluZGV4XCIpO1xyXG4vL1xyXG4vLyAgICAgICAgLy8gQWRkIHNvbWUgZGF0YVxyXG4vLyAgICAgICAgc3RvcmUucHV0KHtpZDogMTIzNDUsIG5hbWU6IHtmaXJzdDogXCJKb2huXCIsIGxhc3Q6IFwiRG9lXCJ9LCBhZ2U6IDQyfSk7XHJcbi8vICAgICAgICBzdG9yZS5wdXQoe2lkOiA2Nzg5MCwgbmFtZToge2ZpcnN0OiBcIkJvYlwiLCBsYXN0OiBcIlNtaXRoXCJ9LCBhZ2U6IDM1fSk7XHJcbi8vICAgICAgICBcclxuLy8gICAgICAgIC8vIFF1ZXJ5IHRoZSBkYXRhXHJcbi8vICAgICAgICB2YXIgZ2V0Sm9obiA9IHN0b3JlLmdldCgxMjM0NSk7XHJcbi8vICAgICAgICB2YXIgZ2V0Qm9iID0gaW5kZXguZ2V0KFtcIlNtaXRoXCIsIFwiQm9iXCJdKTtcclxuLy9cclxuLy8gICAgICAgIGdldEpvaG4ub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XHJcbi8vICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0Sm9obi5yZXN1bHQubmFtZS5maXJzdCk7ICAvLyA9PiBcIkpvaG5cIlxyXG4vLyAgICAgICAgfTtcclxuLy9cclxuLy8gICAgICAgIGdldEJvYi5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcclxuLy8gICAgICAgICAgICBjb25zb2xlLmxvZyhnZXRCb2IucmVzdWx0Lm5hbWUuZmlyc3QpOyAgIC8vID0+IFwiQm9iXCJcclxuLy8gICAgICAgIH07XHJcbi8vXHJcbi8vICAgICAgICAvLyBDbG9zZSB0aGUgZGIgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgZG9uZVxyXG4vLyAgICAgICAgdHgub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4vLyAgICAgICAgICAgIGRiLmNsb3NlKCk7XHJcbi8vICAgICAgICB9O1xyXG4vLyAgICB9XHJcbiAgICBcclxuICAgIGV4cG9ydHMudGVzdCA9ICgpID0+IHtcclxuLy8gICAgICAgIGNvbnNvbGUubG9nKCcyMzIzMjIzJyk7XHJcbi8vICAgICAgICBleHBvcnRzLnB1dCgnYmFzZTEnLCB7XHJcbi8vICAgICAgICAgICAgJ3NkJzoxMixcclxuLy8gICAgICAgIH0sIGxvZ2VycjIpO1xyXG4vLyAgICAgICAgZXhwb3J0cy5wdXQoJ2Jhc2UyJywge1xyXG4vLyAgICAgICAgICAgICdzc2RzZGQnOjE2NTQ2NTQsXHJcbi8vICAgICAgICB9LCBsb2dlcnIyKTtcclxuLy8gICAgICAgIGV4cG9ydHMuZ2V0KCdiYXNlMScsIChlcnIsIGJhc2UpID0+IHtcclxuLy8gICAgICAgICAgICBpZihlcnIpIHtjb25zb2xlLmxvZyhlcnIpOyByZXR1cm47fVxyXG4vLyAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UpO1xyXG4vLyAgICAgICAgfSk7XHJcbi8vICAgICAgICBleHBvcnRzLmdldCgnYmFzZTMnLCAoZXJyLCBiYXNlKSA9PiB7XHJcbi8vICAgICAgICAgICAgaWYoZXJyKSB7Y29uc29sZS5sb2coZXJyKTsgcmV0dXJuO31cclxuLy8gICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlKTtcclxuLy8gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBsb2dlcnIoZXJyKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgbG9nZXJyMiA9IChlcnIpID0+IHtcclxuICAgICAgICBpZihlcnIpIHtjb25zb2xlLmxvZyhlcnIpOyByZXR1cm47fVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY29ubmVjdERCKGNhbGxiYWNrKXtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKGJhc2VOYW1lLCAxKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBjYWxsYmFjaztcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZShzdG9yZU5hbWUsIHsga2V5UGF0aDogXCJpZFwiIH0pO1xyXG4gICAgICAgICAgICBjb25uZWN0REIoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZXhwb3J0cy5nZXQgPSAoaWQpID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3REQihmdW5jdGlvbihlcnIsIGRiKXtcclxuICAgICAgICAgICAgICAgIGlmKGVycikge3JlamVjdChlcnIpOyByZXR1cm47fVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBkYi50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKS5vYmplY3RTdG9yZShzdG9yZU5hbWUpLmdldChpZCk7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCA/IHJlcXVlc3QucmVzdWx0IDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBleHBvcnRzLnB1dCA9IChpZCwgb2JqKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0REIoZnVuY3Rpb24oZXJyLCBkYil7XHJcbiAgICAgICAgICAgICAgICBpZihlcnIpIHtyZWplY3QoZXJyKTsgcmV0dXJuO31cclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gZGIudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpLm9iamVjdFN0b3JlKHN0b3JlTmFtZSkucHV0KHtpZCwgb2JqfSk7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KSh0aGlzLkxvY2FsQmFzZUFQSSA9IHt9KTsiLCIvKkNvcHlyaWdodCAyMDE4IFRpbW9mZXkgUmVjaGthbG92IDxudHNka0B5YW5kZXgucnU+LCBNYXJpYSBTaWRla2htZW5vdmEgPG1hdGlsZGFfQGxpc3QucnU+XHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuKChleHBvcnRzKSA9PiB7XHJcbiAgICBleHBvcnRzLnJ1blRlc3RzID0gKCkgPT4ge1xyXG4gICAgICAgIHF1ZXJ5RWwoJ2JvZHknKS5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgICB3aW5kb3cuUnVuVGVzdHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5zaG93Q29uc2lzdGVuY3lDaGVja0FsZXJ0ID0gKGNoZWNrUmVzKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoZWNrUmVzID09PSB1bmRlZmluZWQgfHwgY2hlY2tSZXMuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBVdGlscy5hbGVydChnZXRMMTBuKCdvdmVydmlldy1jb25zaXN0ZW5jeS1pcy1vaycpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBVdGlscy5hbGVydChnZXRMMTBuKCdvdmVydmlldy1jb25zaXN0ZW5jeS1wcm9ibGVtLWRldGVjdGVkJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5jbGlja1Rocm91Z2h0SGVhZGVycyA9ICgpID0+IHtcclxuICAgICAgICBsZXQgdGFicyA9IHF1ZXJ5RWxzKCcjbmF2aWdhdGlvbiAubmF2aWdhdGlvbi1idXR0b24nKTtcclxuXHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBsZXQgc3ViVGFic051bSA9IDA7XHJcbiAgICAgICAgZnVuY3Rpb24gcnVuQ2xpY2tlcigpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDw9IHRhYnMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGFic1tpbmRleF0uY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdWJUYWJzTnVtID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVGFicyA9IHF1ZXJ5RWxzKCcjY29udGVudEFyZWEgLm5hdmlnYXRpb24tYnV0dG9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFicyA9IFIuaW5zZXJ0QWxsKGluZGV4ICsgMSwgc3ViVGFicywgdGFicyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViVGFic051bSA9IHN1YlRhYnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJUYWJzTnVtLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChydW5DbGlja2VyLCA1MDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJ1bkNsaWNrZXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5zaG93TW9kdWxlU2NoZW1hID0gKGNoZWNrUmVzKSA9PiB7XHJcbiAgICAgICAgYWRkRWwocXVlcnlFbCgnYm9keScpLCBxdWVyeUVsKCcuY29uc2lzdGVuY3ktY2hlY2stcmVzdWx0LWRpYWxvZycpKTtcclxuICAgICAgICAkKHF1ZXJ5RWwoJy5jb25zaXN0ZW5jeS1jaGVjay1yZXN1bHQtZGlhbG9nJykpLm1vZGFsKCdzaG93Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdCgnLmltYWdlLXBsYWNlIHN2ZycpO1xyXG4gICAgICAgIGNvbnN0IHN2Z0dyb3VwID0gc3ZnLmFwcGVuZCgnZycpO1xyXG4gICAgICAgIGNvbnN0IHJvb3QgPSBzdmdHcm91cC5hcHBlbmQoJ2cnKTtcclxuXHJcbiAgICAgICAgLy8gZGVmaW5lIGFuIGFycm93IGhlYWRcclxuICAgICAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZzptYXJrZXInKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW5kJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMTApXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZZJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMykgLy8gbWFya2VyIHNldHRpbmdzXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCA1KVxyXG4gICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzk5OScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwLjYpIC8vIGFycm93aGVhZCBjb2xvclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVEaWN0ID0gY2hlY2tSZXMubm9kZXMucmVkdWNlKChkaWN0LCBuYW1lLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGRpY3RbbmFtZV0gPSBpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGljdDtcclxuICAgICAgICB9LCB7fSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVXaWR0aCA9IDE3MDtcclxuICAgICAgICBjb25zdCBub2RlSGVpZ2h0ID0gMzA7XHJcblxyXG4gICAgICAgIGNvbnN0IG5hbWUyTm9kZSA9IG5hbWUgPT4gKHtcclxuICAgICAgICAgICAgaWQ6IG5vZGVEaWN0W25hbWVdLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICB3aWR0aDogbm9kZVdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGVIZWlnaHRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcGFpcjJFZGdlID0gKHBhaXIsIGkpID0+ICh7XHJcbiAgICAgICAgICAgIGlkOiBpICsgY2hlY2tSZXMubm9kZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBzb3VyY2U6IG5vZGVEaWN0W3BhaXJbMF1dLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5vZGVEaWN0W3BhaXJbMV1dXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdyYXBoID0ge1xyXG4gICAgICAgICAgICBub2RlczogY2hlY2tSZXMubm9kZXMubWFwKG5hbWUyTm9kZSksXHJcbiAgICAgICAgICAgIGxpbmtzOiBjaGVja1Jlcy5lZGdlcy5tYXAocGFpcjJFZGdlKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGxheW91dGVyID0ga2xheS5kM2FkYXB0ZXIoKTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IDk2MDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSA2MDA7XHJcblxyXG4gICAgICAgIGxheW91dGVyXHJcbiAgICAgICAgICAgIC5ub2RlcyhncmFwaC5ub2RlcylcclxuICAgICAgICAgICAgLmxpbmtzKGdyYXBoLmxpbmtzKVxyXG4gICAgICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXHJcbiAgICAgICAgICAgIC50cmFuc2Zvcm1Hcm91cChyb290KVxyXG4gICAgICAgICAgICAub3B0aW9ucyh7XHJcbiAgICAgICAgICAgICAgICBlZGdlUm91dGluZzogJ09SVEhPR09OQUwnLFxyXG4gICAgICAgICAgICAgICAgaW50Q29vcmRpbmF0ZXM6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5kZWZhdWx0UG9ydFNpemUoWzIsIDJdKVxyXG4gICAgICAgICAgICAuc3RhcnQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGluayA9IHJvb3Quc2VsZWN0QWxsKCcubGluaycpXHJcbiAgICAgICAgICAgIC5kYXRhKGdyYXBoLmxpbmtzKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsICdNMCAwJylcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCAndXJsKCNlbmQpJyk7XHJcblxyXG4gICAgICAgIC8vIHdlIGdyb3VwIG5vZGVzIGFsb25nIHdpdGggdGhlaXIgcG9ydHNcclxuICAgICAgICBjb25zdCBub2RlID0gcm9vdC5zZWxlY3RBbGwoJy5ub2RlJylcclxuICAgICAgICAgICAgLmRhdGEoZ3JhcGgubm9kZXMpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKTtcclxuXHJcbiAgICAgICAgbm9kZS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IGNoZWNrUmVzLmRldGFpbHNbZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vZGUgdmFsaWQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdub2RlIGludmFsaWQnO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBub2RlV2lkdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBub2RlSGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cigncngnLCA1KVxyXG4gICAgICAgICAgICAuYXR0cigncnknLCA1KVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMCk7XHJcblxyXG4gICAgICAgIG5vZGUuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBub2RlV2lkdGggLyAyKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG5vZGVIZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAudGV4dChkID0+IGQubmFtZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICc0cHgnKTtcclxuXHJcbiAgICAgICAgLy8gcG9ydHNcclxuICAgICAgICBjb25zdCBwb3J0ID0gbm9kZS5zZWxlY3RBbGwoJy5wb3J0JylcclxuICAgICAgICAgICAgLmRhdGEoZCA9PiBkLnBvcnRzKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvcnQnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAyKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIDApO1xyXG5cclxuICAgICAgICAvLyBhcHBseSBsYXlvdXRcclxuICAgICAgICBsYXlvdXRlci5vbignZmluaXNoJywgKGQyKSA9PiB7XHJcbiAgICAgICAgLy8gYXBwbHkgZWRnZSByb3V0ZXNcclxuICAgICAgICAgICAgbGluay50cmFuc2l0aW9uKCkuYXR0cignZCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0aCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgcGF0aCArPSBgTSR7ZC5zb3VyY2VQb2ludC54fSAke2Quc291cmNlUG9pbnQueX0gYDtcclxuICAgICAgICAgICAgICAgIGQuYmVuZFBvaW50cy5mb3JFYWNoKChicCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gYEwke2JwLnh9ICR7YnAueX0gYDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcGF0aCArPSBgTCR7ZC50YXJnZXRQb2ludC54fSAke2QudGFyZ2V0UG9pbnQueX0gYDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IG5vZGUgcG9zaXRpb25zXHJcbiAgICAgICAgICAgIG5vZGUudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKCR7ZC54fSAke2QueX0pYCk7XHJcblxyXG4gICAgICAgICAgICAvLyBhcHBseSBwb3J0IHBvc2l0aW9uc1xyXG4gICAgICAgICAgICBwb3J0LnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGQueClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZCA9PiBkLnkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsYXlvdXRlci5zdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5zaG93RGlmZkV4YW1wbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgYWRkRWwocXVlcnlFbCgnYm9keScpLCBxdWVyeUVsKCcuc2hvdy1kaWZmLWRpYWxvZycpKTtcclxuICAgICAgICAkKHF1ZXJ5RWwoJy5zaG93LWRpZmYtZGlhbG9nJykpLm1vZGFsKCdzaG93Jyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgREJNUy5nZXRMb2coMCwge1xyXG4gICAgICAgICAgICBhY3Rpb246XCJzZXRNZXRhSW5mb1wiLFxyXG4gICAgICAgICAgICBkYXRlOlwiXCIsXHJcbiAgICAgICAgICAgIHBhcmFtczpcIlwiLFxyXG4gICAgICAgICAgICBzdGF0dXM6XCJPS1wiLFxyXG4gICAgICAgICAgICB1c2VyOlwiXCJcclxuICAgICAgICB9LCAoZXJyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gY2xlYXJFbChxdWVyeUVsKCcuc2hvdy1kaWZmLWRpYWxvZyAuY29udGFpbmVyLWZsdWlkJykpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYWRkRWxzKGVsLCBSLmFwZXJ0dXJlKDIsIGRhdGEucmVxdWVzdGVkTG9nKS5tYXAocGFpciA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBxbXRlKCcuZGlmZi1yb3ctdG1wbCcpO1xyXG4gICAgICAgICAgICAgICAgYWRkRWwocWVlKHJvdywgJy5maXJzdCAudXNlcicpLCBtYWtlVGV4dChwYWlyWzBdWzFdKSk7XHJcbiAgICAgICAgICAgICAgICBhZGRFbChxZWUocm93LCAnLmZpcnN0IC50aW1lJyksIG1ha2VUZXh0KG5ldyBEYXRlKHBhaXJbMF1bMl0pLmZvcm1hdCgneXl5eS9tbS9kZCBoOk1NJykpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VGV4dCA9IEpTT04ucGFyc2UocGFpclswXVs0XSlbMV07XHJcbiAgICAgICAgICAgICAgICBhZGRFbChxZWUocm93LCAnLmZpcnN0IC50ZXh0JyksIG1ha2VUZXh0KGZpcnN0VGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBhZGRFbChxZWUocm93LCAnLmxhc3QgLnVzZXInKSwgbWFrZVRleHQocGFpclsxXVsxXSkpO1xyXG4gICAgICAgICAgICAgICAgYWRkRWwocWVlKHJvdywgJy5sYXN0IC50aW1lJyksIG1ha2VUZXh0KG5ldyBEYXRlKHBhaXJbMV1bMl0pLmZvcm1hdCgneXl5eS9tbS9kZCBoOk1NJykpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUZXh0ID0gSlNPTi5wYXJzZShwYWlyWzFdWzRdKVsxXTtcclxuICAgICAgICAgICAgICAgIGFkZEVsKHFlZShyb3csICcubGFzdCAudGV4dCcpLCBtYWtlVGV4dChsYXN0VGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLy8vICAgICAgICBjb25zdCBkaWZmID0gSnNEaWZmLmRpZmZDaGFycyhwcmV2RGF0YVs0XSB8fCAnJywgcm93RGF0YVs0XSk7XHJcbiAgICAgICAgICAgICAgICAvLy8vICAgICAgICBjb25zdCBkaWZmID0gSnNEaWZmLmRpZmZXb3JkcyhwcmV2RGF0YVs0XSB8fCAnJywgcm93RGF0YVs0XSk7XHJcbi8vICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBKc0RpZmYuZGlmZldvcmRzV2l0aFNwYWNlKGZpcnN0VGV4dCwgbGFzdFRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IEpzRGlmZi5kaWZmV29yZHNXaXRoU3BhY2UobGFzdFRleHQsIGZpcnN0VGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbHMgPSBkaWZmLm1hcCggcGFydCA9PlxyXG4gICAgICAgICAgICAgICAgICAgIFtwYXJ0LnZhbHVlLCAocGFydC5hZGRlZCA/ICdhZGRlZCcgOiAocGFydC5yZW1vdmVkID8gJ3JlbW92ZWQnIDogJ3NhbWUnKSldKS5tYXAocGFpciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZENsYXNzZXMoYWRkRWwobWFrZUVsKCdzcGFuJyksIG1ha2VUZXh0KHBhaXJbMF0pKSwgWydsb2ctZGlmZicsIHBhaXJbMV1dKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYWRkRWxzKHFlZShyb3csICcuZGlmZiAudGV4dCcpLCBlbHMpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSlcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0IGdldEFsbFN1YnNldHMgPSB0aGVBcnJheSA9PiB0aGVBcnJheS5yZWR1Y2UoKHN1YnNldHMsIHZhbHVlKSA9PiBcclxuICAgICAgICBzdWJzZXRzLmNvbmNhdChzdWJzZXRzLm1hcChzZXQgPT4gW3ZhbHVlLC4uLnNldF0pKSxbW11dKTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5hZGRHcm91cFRlc3RpbmdEYXRhID0gKCkgPT4ge1xyXG4gICAgICAgIERCTVMuY3JlYXRlUHJvZmlsZUl0ZW0oJ2NoYXJhY3RlcicsICd0ZXh0JywgJ3RleHQnLCAwLCAoKSA9PiAnJyk7XHJcbiAgICAgICAgREJNUy5jcmVhdGVQcm9maWxlSXRlbSgnY2hhcmFjdGVyJywgJ3N0cmluZycsICdzdHJpbmcnLCAwLCAoKSA9PiAnJyk7XHJcbiAgICAgICAgREJNUy5jcmVhdGVQcm9maWxlSXRlbSgnY2hhcmFjdGVyJywgJ2NoZWNrYm94JywgJ2NoZWNrYm94JywgMCwgKCkgPT4gJycpO1xyXG4gICAgICAgIERCTVMuY3JlYXRlUHJvZmlsZUl0ZW0oJ2NoYXJhY3RlcicsICdudW1iZXInLCAnbnVtYmVyJywgMCwgKCkgPT4gJycpO1xyXG4gICAgICAgIERCTVMuY3JlYXRlUHJvZmlsZUl0ZW0oJ2NoYXJhY3RlcicsICdlbnVtJywgJ2VudW0nLCAwLCAoKSA9PiAnJyk7XHJcbiAgICAgICAgREJNUy5jcmVhdGVQcm9maWxlSXRlbSgnY2hhcmFjdGVyJywgJ211bHRpRW51bScsICdtdWx0aUVudW0nLCAwLCAoKSA9PiAnJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgREJNUy51cGRhdGVEZWZhdWx0VmFsdWUoXCJjaGFyYWN0ZXJcIixcImVudW1cIixcIjEsMiwzXCIsICgpID0+ICcnKTtcclxuICAgICAgICBEQk1TLnVwZGF0ZURlZmF1bHRWYWx1ZShcImNoYXJhY3RlclwiLFwibXVsdGlFbnVtXCIsXCIxLDIsMyw0XCIsICgpID0+ICcnKTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBtYWtlQ2hhciA9IChuYW1lLCBwcm9maWxlSXRlbSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgREJNUy5jcmVhdGVQcm9maWxlKFwiY2hhcmFjdGVyXCIsIG5hbWUsICgpID0+ICcnKTtcclxuICAgICAgICAgICAgREJNUy51cGRhdGVQcm9maWxlRmllbGQoXCJjaGFyYWN0ZXJcIiwgbmFtZSwgcHJvZmlsZUl0ZW0sIHByb2ZpbGVJdGVtLCB2YWx1ZSwgKCkgPT4gJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBtYWtlR3JvdXAgPSAobmFtZSwgcHJvZmlsZUl0ZW0sIG9iaikgPT4ge1xyXG4gICAgICAgICAgICBEQk1TLmNyZWF0ZUdyb3VwKG5hbWUsICgpID0+ICcnKTtcclxuICAgICAgICAgICAgREJNUy5zYXZlRmlsdGVyVG9Hcm91cChuYW1lLCBbUi5tZXJnZShvYmosIHtcInR5cGVcIjpwcm9maWxlSXRlbSxcIm5hbWVcIjpcInByb2ZpbGUtXCIgKyBwcm9maWxlSXRlbX0pXSwgKCkgPT4gJycpO1xyXG4gICAgICAgIH1cclxuLy8gICAgICAgIFxyXG4vLyAgICAgICAgXHJcbi8vICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0gWzEsMiwzXTtcclxuLy8gICAgICAgIGVudW1WYWx1ZXMubWFwKHZhbHVlID0+IG1ha2VDaGFyKCdjaGFyIGVudW0gJyArIHZhbHVlLCAnZW51bScsIFN0cmluZyh2YWx1ZSkpKTtcclxuLy8gICAgICAgIGdldEFsbFN1YnNldHMoZW51bVZhbHVlcykubWFwKCBhcnIgPT4ge1xyXG4vLyAgICAgICAgICAgIGNvbnN0IG9iaiA9IGFyci5yZWR1Y2UoIChhY2MsIHZhbCkgPT4ge1xyXG4vLyAgICAgICAgICAgICAgICBhY2NbU3RyaW5nKHZhbCldID0gdHJ1ZTtcclxuLy8gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuLy8gICAgICAgICAgICB9LCB7fSk7XHJcbi8vICAgICAgICAgICAgbWFrZUdyb3VwKCdncm91cCBlbnVtICcgKyBhcnIuam9pbignLCcpLCAnZW51bScsIHtzZWxlY3RlZE9wdGlvbnM6IG9ian0pO1xyXG4vLyAgICAgICAgfSk7XHJcbi8vICAgICAgICBcclxuLy8gICAgICAgIGNvbnN0IG11bHRpRW51bUNvbmRpdGlvbnMgPSBbJ2V2ZXJ5JywnZXF1YWwnLCdzb21lJ107XHJcbiAgICAgICAgLy8gYnVnIGluIGNvbmRpdGlvbiBjb21iaW5hdGlvbiBcclxuLy8gICAgICAgIFsnZXZlcnknXVxyXG4vLyAgICAgICAgWydldmVyeScsJ2VxdWFsJ11cclxuLy8gICAgICAgIFsnZXZlcnknLCdzb21lJ10gLi4uXHJcbiAgICAgICAgY29uc3QgbXVsdGlFbnVtVmFsdWVzID0gWzEsMiwzXTtcclxuICAgICAgICBjb25zdCBtdWx0aUVudW1WYWx1ZXMyID0gWzEsMiwzLDRdO1xyXG4gICAgICAgIGNvbnN0IG11bHRpRW51bUNvbmRpdGlvbnMgPSBbJ2V2ZXJ5JywnZXF1YWwnXTtcclxuICAgICAgICBnZXRBbGxTdWJzZXRzKG11bHRpRW51bVZhbHVlczIpLm1hcCh2YWx1ZSA9PiBtYWtlQ2hhcignY2hhciBtdWx0aUVudW0gJyArIHZhbHVlLmpvaW4oJywnKSwgJ211bHRpRW51bScsIFN0cmluZyh2YWx1ZS5qb2luKCcsJykpKSk7XHJcbiAgICAgICAgbXVsdGlFbnVtQ29uZGl0aW9ucy5tYXAoY29uZGl0aW9uID0+IHtcclxuICAgICAgICAgICAgZ2V0QWxsU3Vic2V0cyhtdWx0aUVudW1WYWx1ZXMpLm1hcCggYXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGFyci5yZWR1Y2UoIChhY2MsIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY1tTdHJpbmcodmFsKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgICAgICAgICBtYWtlR3JvdXAoJ2dyb3VwIG11bHRpRW51bSAnICsgY29uZGl0aW9uICsgJyAnICsgYXJyLmpvaW4oJywnKSwgJ211bHRpRW51bScsIHtzZWxlY3RlZE9wdGlvbnM6IG9iaiwgY29uZGl0aW9ufSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4vLyAgICAgICAgXHJcbi8vICAgICAgICBcclxuLy8gICAgICAgIGNvbnN0IG51bWJlcnMgPSBbMCwxLDIsMyw0XTtcclxuLy8gICAgICAgIGNvbnN0IHN1Yk51bWJlcnMgPSBbMSwyLDNdO1xyXG4vLyAgICAgICAgY29uc3QgbnVtYmVyQ29uZGl0aW9ucyA9IFsnZ3JlYXRlcicsJ2VxdWFsJywnbGVzc2VyJ107XHJcbi8vICAgICAgICBudW1iZXJzLm1hcCh2YWx1ZSA9PiBtYWtlQ2hhcignY2hhciBudW1iZXIgJyArIHZhbHVlLCAnbnVtYmVyJywgKHZhbHVlKSkpO1xyXG4vLyAgICAgICAgbnVtYmVyQ29uZGl0aW9ucy5tYXAoY29uZGl0aW9uID0+IHtcclxuLy8gICAgICAgICAgICBzdWJOdW1iZXJzLm1hcCggbnVtID0+IHtcclxuLy8gICAgICAgICAgICAgICAgbWFrZUdyb3VwKCdncm91cCBudW1iZXIgJyArIGNvbmRpdGlvbiArICcgJyArIG51bSwgJ251bWJlcicsIHtudW0sIGNvbmRpdGlvbn0pO1xyXG4vLyAgICAgICAgICAgIH0pO1xyXG4vLyAgICAgICAgfSk7XHJcbi8vICAgICAgICBcclxuLy8gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBbdHJ1ZSwgZmFsc2VdO1xyXG4vLyAgICAgICAgY2hlY2tib3hlcy5tYXAodmFsdWUgPT4gbWFrZUNoYXIoJ2NoYXIgY2hlY2tib3ggJyArIHZhbHVlLCAnY2hlY2tib3gnLCB2YWx1ZSkpO1xyXG4vLyAgICAgICAgZ2V0QWxsU3Vic2V0cyhjaGVja2JveGVzKS5tYXAoIGFyciA9PiB7XHJcbi8vICAgICAgICAgICAgY29uc3Qgb2JqID0gYXJyLnJlZHVjZSggKGFjYywgdmFsKSA9PiB7XHJcbi8vICAgICAgICAgICAgICAgIGFjY1tTdHJpbmcodmFsKV0gPSB0cnVlO1xyXG4vLyAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4vLyAgICAgICAgICAgIH0sIHt9KTtcclxuLy8gICAgICAgICAgICBtYWtlR3JvdXAoJ2dyb3VwIGNoZWNrYm94ICcgKyBhcnIuam9pbignLCcpLCAnY2hlY2tib3gnLCB7c2VsZWN0ZWRPcHRpb25zOiBvYmp9KTtcclxuLy8gICAgICAgIH0pO1xyXG4vLyAgICAgICAgXHJcbi8vICAgICAgICBjb25zdCBjaGFycyA9IFsnYScsJ2InLCdjJywnZCddO1xyXG4vLyAgICAgICAgY29uc3Qgc3ViQ2hhcnMgPSBbJ2EnLCdiJywnYyddO1xyXG4vLyAgICAgICAgZ2V0QWxsU3Vic2V0cyhjaGFycykubWFwKHZhbHVlID0+IG1ha2VDaGFyKCdjaGFyIHN0cmluZyAnICsgdmFsdWUuam9pbignJyksICdzdHJpbmcnLCBTdHJpbmcodmFsdWUuam9pbignJykpKSk7XHJcbi8vICAgICAgICBnZXRBbGxTdWJzZXRzKGNoYXJzKS5tYXAodmFsdWUgPT4gbWFrZUNoYXIoJ2NoYXIgdGV4dCAnICsgdmFsdWUuam9pbignJyksICd0ZXh0JywgU3RyaW5nKHZhbHVlLmpvaW4oJycpKSkpO1xyXG4vLyAgICAgICAgXHJcbi8vICAgICAgICBnZXRBbGxTdWJzZXRzKHN1YkNoYXJzKS5tYXAoIGFyciA9PiB7XHJcbi8vICAgICAgICAgICAgbWFrZUdyb3VwKCdncm91cCBzdHJpbmcgJyArIGFyci5qb2luKCcnKSwgJ3N0cmluZycsIHtyZWdleFN0cmluZzogYXJyLmpvaW4oJycpfSk7XHJcbi8vICAgICAgICB9KTtcclxuLy8gICAgICAgIGdldEFsbFN1YnNldHMoc3ViQ2hhcnMpLm1hcCggYXJyID0+IHtcclxuLy8gICAgICAgICAgICBtYWtlR3JvdXAoJ2dyb3VwIHRleHQgJyArIGFyci5qb2luKCcnKSwgJ3RleHQnLCB7cmVnZXhTdHJpbmc6IGFyci5qb2luKCcnKX0pO1xyXG4vLyAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pKHRoaXMuVGVzdFV0aWxzID0ge30pO1xyXG4iLCIvKkNvcHlyaWdodCAyMDE1LTIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT4sIE1hcmlhIFNpZGVraG1lbm92YSA8bWF0aWxkYV9AbGlzdC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIsdmFycy1vbi10b3AgKi9cclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgZXhwb3J0cy5jcmVhdGVNb2RhbERpYWxvZyA9IChyb290LCBvbkFjdGlvbiwgb3B0cykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbW1vbnMgPSAnLmRpYWxvZy1jb21tb25zICc7XHJcbiAgICAgICAgY29uc3QgZWwyID0gd3JhcEVsKCdkaXYnLCBxdGUoYCR7Y29tbW9uc30gLnJlcXVlc3QtZGF0YS1kaWFsb2ctdG1wbGApKTtcclxuICAgICAgICBjb25zdCBlbCA9IHFlZShlbDIsICcubW9kYWwnKTtcclxuICAgICAgICBpZiAob3B0cy5kaWFsb2dDbGFzcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsLCBvcHRzLmRpYWxvZ0NsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYm9keSA9IHFlZShlbCwgJy5tb2RhbC1ib2R5Jyk7XHJcbiAgICAgICAgYWRkRWwoYm9keSwgcXRlKGAke2NvbW1vbnN9IC4ke29wdHMuYm9keVNlbGVjdG9yfWApKTtcclxuICAgICAgICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgUi50b1BhaXJzKG9wdHMuYm9keSkubWFwKHBhaXIgPT4gc2V0QXR0cihxZWUoYm9keSwgcGFpclswXSksICdsMTBuLWlkJywgcGFpclsxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0cy5pbml0Qm9keSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdHMuaW5pdEJvZHkoYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZEVsKGJvZHksIHF0ZShgJHtjb21tb25zfSAubW9kYWwtZXJyb3ItYmxvY2tgKSk7XHJcbiAgICAgICAgc2V0QXR0cihxZWUoZWwsICcubW9kYWwtdGl0bGUnKSwgJ2wxMG4taWQnLCBvcHRzLmRpYWxvZ1RpdGxlKTtcclxuICAgICAgICBzZXRBdHRyKHFlZShlbCwgJy5vbi1hY3Rpb24tYnV0dG9uJyksICdsMTBuLWlkJywgb3B0cy5hY3Rpb25CdXR0b25UaXRsZSk7XHJcbiAgICAgICAgTDEwbi5sb2NhbGl6ZVN0YXRpYyhlbCk7XHJcbiAgICAgICAgbGlzdGVuKHFlZShlbCwgJy5vbi1hY3Rpb24tYnV0dG9uJyksICdjbGljaycsIG9uQWN0aW9uKGVsKSk7XHJcbiAgICAgICAgZWwuc2hvd0RsZyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2xlYXJFcnJvcihlbCk7XHJcbiAgICAgICAgICAgICQoZWwpLm1vZGFsKCdzaG93Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZSA9IHFlZShib2R5LCAnLmZvY3VzYWJsZScpO1xyXG4gICAgICAgICAgICBpZihmb2N1c2FibGUgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBmb2N1c2FibGUuZm9jdXMoKSwgNTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgb25lbnRlcmFibGUgPSBxZWVzKGJvZHksICcub25lbnRlcmFibGUnKTtcclxuICAgICAgICBpZihvbmVudGVyYWJsZS5sZW5ndGggIT09IDApe1xyXG4gICAgICAgICAgICBvbmVudGVyYWJsZS5mb3JFYWNoKGxpc3Rlbk9uRW50ZXIoUi5fXywgb25BY3Rpb24oZWwpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLmhpZGVEbGcgPSAoKSA9PiAkKGVsKS5tb2RhbCgnaGlkZScpO1xyXG4gICAgICAgIGxpc3RlbihxZWUoZWwsICcub24tY2FuY2VsLWJ1dHRvbicpLCAnY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLmhpZGVEbGcoKVxyXG4gICAgICAgICAgICBpZihvcHRzLm9uQ2FuY2VsKSBvcHRzLm9uQ2FuY2VsKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlzdGVuKHFlZShlbCwgJy5vbi1jbG9zZS1idXR0b24nKSwgJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBlbC5oaWRlRGxnKClcclxuICAgICAgICAgICAgaWYob3B0cy5vbkNhbmNlbCkgb3B0cy5vbkNhbmNlbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZEVsKHFlKHJvb3QpLCBlbCk7XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmluaXRUYWJQYW5lbCA9ICh0YWJDbGF6eiwgY29udGFpbmVyQ2xhenopID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXJzID0gZ2V0RWxzKGNvbnRhaW5lckNsYXp6KTtcclxuXHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHsgLy8gZG9uJ3QgaGlkZSAxc3QgZWxlbWVudFxyXG4gICAgICAgICAgICBhZGRDbGFzcyhjb250YWluZXJzW2ldLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YWJCdXR0b25zID0gZ2V0RWxzKHRhYkNsYXp6KTtcclxuXHJcbiAgICAgICAgYWRkQ2xhc3ModGFiQnV0dG9uc1swXSwgJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFiQnV0dG9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaXN0ZW4odGFiQnV0dG9uc1tpXSwgJ2NsaWNrJywgdGFiQnV0dG9uQ2xpY2sodGFiQnV0dG9ucywgY29udGFpbmVycykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRhYkJ1dHRvbkNsaWNrID0gKGJ1dHRvbnMsIGNvbnRhaW5lcnMpID0+IChldmVudCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKGJ1dHRvbnNbaV0sICdhY3RpdmUnLCBldmVudC50YXJnZXQuaWQgPT09IGJ1dHRvbnNbaV0uaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaGlkZUVsKGNvbnRhaW5lcnNbaV0sIGAke2V2ZW50LnRhcmdldC5pZH1Db250YWluZXJgICE9PSBjb250YWluZXJzW2ldLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZmlsbFNob3dJdGVtU2VsZWN0b3IgPSAoc2VsZWN0b3IsIGRpc3BsYXlBcnJheSkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBzZXRBdHRyKHNlbGVjdG9yLCAnc2l6ZScsIGRpc3BsYXlBcnJheS5sZW5ndGgpO1xyXG4gICAgICAgIGRpc3BsYXlBcnJheS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBlbCA9IHNldFByb3BzKG1ha2VFbCgnb3B0aW9uJyksIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGlkZUVsKGVsLCB2YWx1ZS5oaWRkZW4pO1xyXG4gICAgICAgICAgICBhZGRFbChzZWxlY3RvciwgYWRkRWwoZWwsIG1ha2VUZXh0KHZhbHVlLm5hbWUpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZmlsbFNob3dJdGVtU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBvcHRpb25Hcm91cHMsIHNldFNpemUpID0+IHtcclxuICAgICAgICBsZXQgZWwsIGdyb3VwRWwsIGNvdW50ZXIgPSAwO1xyXG4gICAgICAgIGFkZEVscyhzZWxlY3Rvciwgb3B0aW9uR3JvdXBzLm1hcCgoZ3JvdXApID0+IHtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICBncm91cEVsID0gc2V0QXR0cihtYWtlRWwoJ29wdGdyb3VwJyksICdsYWJlbCcsIGdyb3VwLmRpc3BsYXlOYW1lKTtcclxuICAgICAgICAgICAgYWRkRWxzKGdyb3VwRWwsIGdyb3VwLmFycmF5Lm1hcCgob3B0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbCA9IHNldFByb3BzKG1ha2VFbCgnb3B0aW9uJyksIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc2V0QXR0cihlbCwgJ3ZhbHVlJywgb3B0aW9uLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVsKGVsLCBtYWtlVGV4dChvcHRpb24uZGlzcGxheU5hbWUpKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBFbDtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgaWYoc2V0U2l6ZSkge1xyXG4gICAgICAgICAgICBzZXRBdHRyKHNlbGVjdG9yLCAnc2l6ZScsIGNvdW50ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4vLyAgICBleHBvcnRzLnNob3dTZWxlY3RlZEVscyA9IGNsYXNzS2V5ID0+IChldmVudCkgPT4ge1xyXG4vLyAgICAgICAgY29uc3QgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuLy8gICAgICAgIGNvbnN0IGVsID0gZXZlbnQudGFyZ2V0O1xyXG4vLyAgICAgICAgbGV0IGVscywgaSwgajtcclxuLy8gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XHJcbi8vICAgICAgICAgICAgZWxzID0gZ2V0RWxzKGNsYXNzS2V5ICsgaSk7XHJcbi8vICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGVscy5sZW5ndGg7IGorKykge1xyXG4vLyAgICAgICAgICAgICAgICBoaWRlRWwoZWxzW2pdLCAhZWwub3B0aW9uc1tpXS5zZWxlY3RlZCk7XHJcbi8vICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgfVxyXG4vLyAgICAgICAgY29uc29sZS5sb2coJ3Nob3dTZWxlY3RlZEVscyB0aW1lICcgKyAocGVyZm9ybWFuY2Uubm93KCkgLSB0MSkgKyAnIG1zJyk7XHJcbi8vICAgIH07XHJcbi8vICAgIFxyXG4vLyAgICBleHBvcnRzLnNob3dTZWxlY3RlZEVsczIgPSAocm9vdCwgY2xhc3NLZXkpID0+IChldmVudCkgPT4ge1xyXG4vLyAgICAgICAgY29uc3QgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuLy8gICAgICAgIGNvbnN0IGVsID0gZXZlbnQudGFyZ2V0O1xyXG4vLyAgICAgICAgbGV0IGVscywgaSwgajtcclxuLy8gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XHJcbi8vICAgICAgICAgICAgZWxzID0gcXVlcnlFbHMocm9vdCArICcgLicgKyBjbGFzc0tleSArIGkpO1xyXG4vLyAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBlbHMubGVuZ3RoOyBqKyspIHtcclxuLy8gICAgICAgICAgICAgICAgaGlkZUVsKGVsc1tqXSwgIWVsLm9wdGlvbnNbaV0uc2VsZWN0ZWQpO1xyXG4vLyAgICAgICAgICAgIH1cclxuLy8gICAgICAgIH1cclxuLy8gICAgICAgIGNvbnNvbGUubG9nKCdzaG93U2VsZWN0ZWRFbHMyIHRpbWUgJyArIChwZXJmb3JtYW5jZS5ub3coKSAtIHQxKSArICcgbXMnKTtcclxuLy8gICAgfTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5zaG93U2VsZWN0ZWRFbHMzID0gKHJvb3QsIGNsYXNzS2V5LCBhdHRyKSA9PiAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGVsID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIGxldCBpLCBqO1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIG1hcFtpXSA9IGVsLm9wdGlvbnNbaV0uc2VsZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVscyA9IHF1ZXJ5RWxzKHJvb3QgKyAnIC4nICsgY2xhc3NLZXkpO1xyXG4gICAgICAgIGVscy5mb3JFYWNoKGVsMiA9PiB7XHJcbiAgICAgICAgICAgIHNob3dFbChlbDIsIG1hcFtnZXRBdHRyKGVsMiwgYXR0cildKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnc2hvd1NlbGVjdGVkRWxzMyB0aW1lICcgKyAocGVyZm9ybWFuY2Uubm93KCkgLSB0MSkgKyAnIG1zJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuaW5pdFNlbGVjdG9yRmlsdGVycyA9ICgpID0+IHtcclxuICAgICAgICBxdWVyeUVscygnW3NlbGVjdG9yLWZpbHRlcl0nKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBxdWVyeUVsKGdldEF0dHIoZWwsICdzZWxlY3Rvci1maWx0ZXInKSk7XHJcbiAgICAgICAgICAgIGVsLnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHNldEF0dHIoZWwsICdsMTBuLXBsYWNlaG9sZGVyLWlkJywgJ2NvbnN0YW50LWZpbHRlcicpO1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbCwgJ2Zvcm0tY29udHJvbCBtYXJnaW4tYm90dG9tLTgnKTtcclxuICAgICAgICAgICAgbGlzdGVuKGVsLCAnaW5wdXQnLCBmaWx0ZXJPcHRpb25zKHNlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZmlsdGVyT3B0aW9ucyA9IHNlbCA9PiAoZXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdmFsID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIGxldCBpLCBvcHQ7XHJcbi8vICAgICAgICB2YWwgPSBDb21tb25VdGlscy5nbG9iU3RyaW5nVG9SZWdleCh2YWwudHJpbSgpLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWwub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBvcHQgPSBzZWwub3B0aW9uc1tpXTtcclxuLy8gICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBvcHQuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCkuc2VhcmNoKHZhbCkgIT09IC0xO1xyXG4gICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBvcHQuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWwpICE9PSAtMTtcclxuICAgICAgICAgICAgaWYgKCFpc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIG9wdC5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhpZGVFbChvcHQsICFpc1Zpc2libGUpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKG9wdCwgXCJoaWRkZW5cIiwgb3B0LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpLnNlYXJjaCh2YWwpID09PSAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmluaXRQYW5lbFRvZ2dsZXIgPSAoZWwpID0+IHtcclxuICAgICAgICBjb25zdCBhdHRyID0gZ2V0QXR0cihlbCwgJ3BhbmVsLXRvZ2dsZXInKTtcclxuICAgICAgICBhZGRDbGFzcyhlbCwgJ2V4cGFuZGVkJyk7XHJcbiAgICAgICAgY29uc3Qgc2VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhdHRyKTtcclxuICAgICAgICBpZiAoc2VsID09IG51bGwpIHtcclxuICAgICAgICAgICAgVXRpbHMuYWxlcnQoYFBhbmVsIHRvZ2dsZXIgaXMgYnJva2VuOiAke2F0dHJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpc3RlbihlbCwgJ2NsaWNrJywgdG9nZ2xlUGFuZWwoZWwsIHNlbCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmluaXRQYW5lbFRvZ2dsZXJzID0gZWwgPT4gcWVlcyhlbCB8fCBkb2N1bWVudCwgJ1twYW5lbC10b2dnbGVyXScpLmZvckVhY2goZXhwb3J0cy5pbml0UGFuZWxUb2dnbGVyKTtcclxuXHJcbiAgICBleHBvcnRzLmF0dGFjaFBhbmVsVG9nZ2xlciA9IChoZWFkZXIsIGNvbnRlbnQsIGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgYWRkQ2xhc3MoaGVhZGVyLCAnZXhwYW5kZWQnKTtcclxuICAgICAgICBsaXN0ZW4oaGVhZGVyLCAnY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsKGhlYWRlciwgY29udGVudCkoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b2dnbGVQYW5lbChoZWFkZXIsIGNvbnRlbnQpKGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdG9nZ2xlUGFuZWwgPSAoZWwsIHNlbCkgPT4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNFeHBhbmRlZCA9IGhhc0NsYXNzKGVsLCAnZXhwYW5kZWQnKTtcclxuICAgICAgICByZW1vdmVDbGFzc2VzKGVsLCBbJ2V4cGFuZGVkJywgJ2NvbGxhcHNlZCddKTtcclxuICAgICAgICBhZGRDbGFzcyhlbCwgaXNFeHBhbmRlZCA/ICdjb2xsYXBzZWQnIDogJ2V4cGFuZGVkJyk7XHJcbiAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsLCAnaGlkZGVuJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMubWFrZUV2ZW50VGltZVBpY2tlciA9IChvcHRzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5wdXQgPSBtYWtlRWwoJ2lucHV0Jyk7XHJcbiAgICAgICAgUi5hcChbYWRkQ2xhc3MoaW5wdXQpXSwgb3B0cy5leHRyYUNsYXNzZXMpO1xyXG4gICAgICAgIGFkZENsYXNzKGlucHV0LCAnZXZlbnRUaW1lJyk7XHJcbiAgICAgICAgaW5wdXQudmFsdWUgPSBvcHRzLmV2ZW50VGltZTtcclxuXHJcbiAgICAgICAgaW5wdXQuZXZlbnRJbmRleCA9IG9wdHMuaW5kZXg7XHJcblxyXG4gICAgICAgIGNvbnN0IHBpY2tlck9wdHMgPSB7XHJcbiAgICAgICAgICAgIGxhbmc6IEwxMG4uZ2V0TGFuZygpLFxyXG4gICAgICAgICAgICBtYXNrOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKG9wdHMucHJlR2FtZURhdGUpLFxyXG4gICAgICAgICAgICBlbmREYXRlOiBuZXcgRGF0ZShvcHRzLmRhdGUpLFxyXG4gICAgICAgICAgICBvbkNoYW5nZURhdGVUaW1lOiBvcHRzLm9uQ2hhbmdlRGF0ZVRpbWVDcmVhdG9yKGlucHV0KSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0cy5ldmVudFRpbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHBpY2tlck9wdHMudmFsdWUgPSBvcHRzLmV2ZW50VGltZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwaWNrZXJPcHRzLnZhbHVlID0gb3B0cy5kYXRlO1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhpbnB1dCwgJ2RlZmF1bHREYXRlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBqUXVlcnkoaW5wdXQpLmRhdGV0aW1lcGlja2VyKHBpY2tlck9wdHMpO1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5tYWtlRXZlbnRUaW1lUGlja2VyMiA9IChpbnB1dCwgb3B0cykgPT4ge1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gb3B0cy5ldmVudFRpbWU7XHJcblxyXG4gICAgICAgIGlucHV0LmV2ZW50SW5kZXggPSBvcHRzLmluZGV4O1xyXG5cclxuICAgICAgICBjb25zdCBwaWNrZXJPcHRzID0ge1xyXG4gICAgICAgICAgICBsYW5nOiBMMTBuLmdldExhbmcoKSxcclxuICAgICAgICAgICAgbWFzazogdHJ1ZSxcclxuICAgICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZShvcHRzLnByZUdhbWVEYXRlKSxcclxuICAgICAgICAgICAgZW5kRGF0ZTogbmV3IERhdGUob3B0cy5kYXRlKSxcclxuICAgICAgICAgICAgb25DaGFuZ2VEYXRlVGltZTogb3B0cy5vbkNoYW5nZURhdGVUaW1lQ3JlYXRvcihpbnB1dCksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZXZlbnRUaW1lICE9PSAnJykge1xyXG4gICAgICAgICAgICBwaWNrZXJPcHRzLnZhbHVlID0gb3B0cy5ldmVudFRpbWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGlja2VyT3B0cy52YWx1ZSA9IG9wdHMuZGF0ZTtcclxuICAgICAgICAgICAgYWRkQ2xhc3MoaW5wdXQsICdkZWZhdWx0RGF0ZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgalF1ZXJ5KGlucHV0KS5kYXRldGltZXBpY2tlcihwaWNrZXJPcHRzKTtcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGJ1ZyBhYm91dCBzZXR0aW5nIDA5MDAgeWVhcnMgaW4gQnJhYXZvcyBnYW1lIGlzIGV2ZW50IGRhdGUuIEZpeGVkIGluIHByb2R1Y3Rpb24uXHJcbiAgICAvLyAgZXhwb3J0cy5tYWtlRXZlbnRUaW1lUGlja2VyID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgIC8vICAgICAgdmFyIGlucHV0ID0gbWFrZUVsKFwiaW5wdXRcIik7XHJcbiAgICAvLyAgICAgIFIuYXAoW2FkZENsYXNzKGlucHV0KV0sIG9wdHMuZXh0cmFDbGFzc2VzKTtcclxuICAgIC8vICAgICAgYWRkQ2xhc3MoaW5wdXQsIFwiZXZlbnRUaW1lXCIpO1xyXG4gICAgLy8gICAgICBpbnB1dC52YWx1ZSA9IG9wdHMuZXZlbnRUaW1lO1xyXG4gICAgLy9cclxuICAgIC8vICAgICAgaW5wdXQuZXZlbnRJbmRleCA9IG9wdHMuaW5kZXg7XHJcbiAgICAvL1xyXG4gICAgLy8gICAgICB2YXIgcGlja2VyT3B0cyA9IHtcclxuICAgIC8vICAgICAgICAgIGxhbmcgOiBMMTBuLmdldExhbmcoKSxcclxuICAgIC8vICAgICAgICAgIG1hc2sgOiB0cnVlLFxyXG4gICAgLy8gICAgICAgICAgc3RhcnREYXRlIDogbmV3IERhdGUob3B0cy5wcmVHYW1lRGF0ZSksXHJcbiAgICAvLyAgICAgICAgICBlbmREYXRlIDogbmV3IERhdGUob3B0cy5kYXRlKSxcclxuICAgIC8vICAgICAgICAgIG9uQ2hhbmdlRGF0ZVRpbWUgOiBvcHRzLm9uQ2hhbmdlRGF0ZVRpbWVDcmVhdG9yKGlucHV0KSxcclxuICAgIC8vICAgICAgfTtcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIHZhciBwaWNrZXIgPSBqUXVlcnkoaW5wdXQpLmRhdGV0aW1lcGlja2VyKHBpY2tlck9wdHMpO1xyXG4gICAgLy9cclxuICAgIC8vICAgICAgdmFyIHZhbHVlO1xyXG4gICAgLy8gICAgICBpZiAob3B0cy5ldmVudFRpbWUgIT09IFwiXCIpIHtcclxuICAgIC8vICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUob3B0cy5ldmVudFRpbWUpO1xyXG4gICAgLy8gICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICAgdmFsdWUgPSBvcHRzLmRhdGU7XHJcbiAgICAvLyAgICAgICAgICBhZGRDbGFzcyhpbnB1dCwgXCJkZWZhdWx0RGF0ZVwiKTtcclxuICAgIC8vICAgICAgfVxyXG4gICAgLy9cclxuICAgIC8vICAgICAgcGlja2VyLnZhbHVlID0gdmFsdWU7XHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgLy8gIH07XHJcblxyXG4gICAgZXhwb3J0cy5pbml0VGV4dEFyZWFzID0gKHNlbCkgPT4ge1xyXG4gICAgICAgIFIuYXAoW2V4cG9ydHMuYXR0YWNoVGV4dGFyZWFSZXNpemVyXSwgcXVlcnlFbHMoc2VsKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMucmVmcmVzaFRleHRBcmVhcyA9IChzZWwpID0+IHtcclxuICAgICAgICBSLmFwKFtleHBvcnRzLnJlc2l6ZVRleHRhcmVhXSwgcXVlcnlFbHMoc2VsKS5tYXAoZWwgPT4gKHsgdGFyZ2V0OiBlbCB9KSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmF0dGFjaFRleHRhcmVhUmVzaXplciA9IChpbnB1dCkgPT4ge1xyXG4gICAgICAgIGxpc3RlbihpbnB1dCwgJ2tleWRvd24nLCBleHBvcnRzLnJlc2l6ZVRleHRhcmVhKTtcclxuICAgICAgICBsaXN0ZW4oaW5wdXQsICdwYXN0ZScsIGV4cG9ydHMucmVzaXplVGV4dGFyZWEpO1xyXG4gICAgICAgIGxpc3RlbihpbnB1dCwgJ2N1dCcsIGV4cG9ydHMucmVzaXplVGV4dGFyZWEpO1xyXG4gICAgICAgIGxpc3RlbihpbnB1dCwgJ2NoYW5nZScsIGV4cG9ydHMucmVzaXplVGV4dGFyZWEpO1xyXG4gICAgICAgIGxpc3RlbihpbnB1dCwgJ2Ryb3AnLCBleHBvcnRzLnJlc2l6ZVRleHRhcmVhKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5yZXNpemVUZXh0YXJlYSA9IChldikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgdGhhdC5zdHlsZS5oZWlnaHQgPSAnMjRweCc7XHJcbiAgICAgICAgdGhhdC5zdHlsZS5oZWlnaHQgPSBgJHt0aGF0LnNjcm9sbEhlaWdodCArIDEyfXB4YDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5yZXNpemVUZXh0YXJlYTIgPSAodGhhdCkgPT4ge1xyXG4gICAgICAgIHRoYXQuc3R5bGUuaGVpZ2h0ID0gJzI0cHgnO1xyXG4gICAgICAgIHRoYXQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhhdC5zY3JvbGxIZWlnaHQgKyAxMn1weGA7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMucG9wdWxhdGVBZGFwdGF0aW9uVGltZUlucHV0ID0gKGlucHV0LCBzdG9yeU5hbWUsIGV2ZW50LCBjaGFyYWN0ZXJOYW1lLCBpc0VkaXRhYmxlKSA9PiB7XHJcbiAgICAgICAgc2V0Q2xhc3NCeUNvbmRpdGlvbihpbnB1dCwgJ25vdEVkaXRhYmxlJywgIWlzRWRpdGFibGUpO1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gZXZlbnQuY2hhcmFjdGVyc1tjaGFyYWN0ZXJOYW1lXS50aW1lO1xyXG4gICAgICAgIGlucHV0LmRhdGFLZXkgPSBKU09OLnN0cmluZ2lmeShbc3RvcnlOYW1lLCBldmVudC5pbmRleCwgY2hhcmFjdGVyTmFtZV0pO1xyXG4gICAgICAgIGxpc3RlbihpbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlUGVyc29uYWxUaW1lRGVsZWdhdGUpO1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uQ2hhbmdlUGVyc29uYWxUaW1lRGVsZWdhdGUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhS2V5ID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQuZGF0YUtleSk7XHJcbiAgICAgICAgY29uc3QgdGltZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcclxuICAgICAgICBEQk1TLnNldEV2ZW50QWRhcHRhdGlvblByb3BlcnR5KGRhdGFLZXlbMF0sIGRhdGFLZXlbMV0sIGRhdGFLZXlbMl0sICd0aW1lJywgdGltZSwgVXRpbHMucHJvY2Vzc0Vycm9yKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLnBvcHVsYXRlUmVhZHlDaGVja2JveCA9IChkaXYsIGlkLCBjaGVja2VkLCBpc0VkaXRhYmxlLCBjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gcWVlKGRpdiwgJ2lucHV0Jyk7XHJcbiAgICAgICAgc2V0Q2xhc3NCeUNvbmRpdGlvbihpbnB1dCwgJ25vdEVkaXRhYmxlJywgIWlzRWRpdGFibGUpO1xyXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgIGlucHV0LmlkID0gaWQ7XHJcbiAgICAgICAgbGlzdGVuKGlucHV0LCAnY2hhbmdlJywgY2FsbGJhY2spO1xyXG4gICAgICAgIHNldEF0dHIocWVlKGRpdiwgJ2xhYmVsJyksICdmb3InLCBpbnB1dC5pZCk7XHJcbiAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5vbkNoYW5nZUFkYXB0YXRpb25SZWFkeVN0YXR1czIgPSBjYWxsYmFjayA9PiAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhS2V5ID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQuaWQpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gIWhhc0NsYXNzKGV2ZW50LnRhcmdldCwgJ2J0bi1wcmltYXJ5Jyk7XHJcbiAgICAgICAgREJNUy5zZXRFdmVudEFkYXB0YXRpb25Qcm9wZXJ0eShkYXRhS2V5WzBdLCBkYXRhS2V5WzFdLCBkYXRhS2V5WzJdLCAncmVhZHknLCB2YWx1ZSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKGV2ZW50LnRhcmdldCwgJ2J0bi1wcmltYXJ5JywgdmFsdWUpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMubWFrZVBhbmVsQ29yZSA9ICh0aXRsZSwgY29udGVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhbmVsID0gYWRkQ2xhc3NlcyhtYWtlRWwoJ2RpdicpLCBbJ3BhbmVsJywgJ3BhbmVsLWRlZmF1bHQnXSk7XHJcbiAgICAgICAgY29uc3QgaDMgPSBhZGRDbGFzcyhhZGRFbChtYWtlRWwoJ2gzJyksIHRpdGxlKSwgJ3BhbmVsLXRpdGxlJyk7XHJcbiAgICAgICAgY29uc3QgYSA9IHNldEF0dHIobWFrZUVsKCdhJyksICdocmVmJywgJyMvJyk7XHJcbiAgICAgICAgc2V0QXR0cihhLCAncGFuZWwtdG9nZ2xlcicsICcnKTtcclxuICAgICAgICBjb25zdCBoZWFkRGl2ID0gYWRkQ2xhc3MobWFrZUVsKCdkaXYnKSwgJ3BhbmVsLWhlYWRpbmcnKTtcclxuICAgICAgICBhZGRFbChwYW5lbCwgYWRkRWwoaGVhZERpdiwgYWRkRWwoYSwgaDMpKSk7XHJcbiAgICAgICAgY29uc3QgY29udGVudERpdiA9IGFkZENsYXNzKG1ha2VFbCgnZGl2JyksICdwYW5lbC1ib2R5Jyk7XHJcbiAgICAgICAgYWRkRWwocGFuZWwsIGFkZEVsKGNvbnRlbnREaXYsIGNvbnRlbnQpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwYW5lbCxcclxuICAgICAgICAgICAgY29udGVudERpdixcclxuICAgICAgICAgICAgYVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMubWFrZVByb2ZpbGVUYWJsZSA9IChwcm9maWxlU3RydWN0dXJlLCBwcm9maWxlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcW10ZSgnLnByb2ZpbGUtZWRpdG9yLWNvbnRhaW5lci10bXBsJyk7XHJcbiAgICAgICAgYWRkQ2xhc3MoY29udGFpbmVyLCAncHJvZmlsZS10YWJsZScpO1xyXG4gICAgICAgIGxldCB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gYWRkRWxzKGNvbnRhaW5lciwgcHJvZmlsZVN0cnVjdHVyZS5maWx0ZXIoZWxlbWVudCA9PiBlbGVtZW50LmRvRXhwb3J0KS5tYXAoKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFkZENsYXNzKG1ha2VFbCgnc3BhbicpLCAnYnJpZWZpbmdUZXh0U3BhbicpO1xyXG4gICAgICAgICAgICAgICAgYWRkRWwodmFsdWUsIG1ha2VUZXh0KHByb2ZpbGVbZWxlbWVudC5uYW1lXSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxyXG4gICAgICAgICAgICBjYXNlICdtdWx0aUVudW0nOlxyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYWtlVGV4dChwcm9maWxlW2VsZW1lbnQubmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbWFrZVRleHQoY29uc3RMMTBuKENvbnN0YW50c1twcm9maWxlW2VsZW1lbnQubmFtZV1dKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlICR7ZWxlbWVudC50eXBlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHFtdGUoJy5wcm9maWxlLWVkaXRvci1yb3ctdG1wbCcpO1xyXG4gICAgICAgICAgICBhZGRFbChxZWUocm93LCAnLnByb2ZpbGUtaXRlbS1uYW1lJyksIG1ha2VUZXh0KGVsZW1lbnQubmFtZSkpO1xyXG4gICAgICAgICAgICBhZGRFbChxZWUocm93LCAnLnByb2ZpbGUtaXRlbS1pbnB1dCcpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiByb3c7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLm1ha2VUYWJsZVJvdyA9IChjb2wxLCBjb2wyKSA9PiBhZGRFbHMobWFrZUVsKCd0cicpLCBbYWRkRWwobWFrZUVsKCd0ZCcpLCBjb2wxKSwgYWRkRWwobWFrZUVsKCd0ZCcpLCBjb2wyKV0pO1xyXG5cclxuICAgIGV4cG9ydHMuY2hlY2tBbmRHZXRFbnRpdHlTZXR0aW5nID0gKHNldHRpbmdzUGF0aCwgbmFtZXMpID0+IHtcclxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IERCTVMuZ2V0U2V0dGluZ3MoKTtcclxuICAgICAgICBpZiAoIXNldHRpbmdzW3NldHRpbmdzUGF0aF0pIHtcclxuICAgICAgICAgICAgc2V0dGluZ3Nbc2V0dGluZ3NQYXRoXSA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVzWzBdLnZhbHVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IG5hbWUgfSA9IHNldHRpbmdzW3NldHRpbmdzUGF0aF07XHJcbiAgICAgICAgY29uc3QgcmF3TmFtZXMgPSBuYW1lcy5tYXAoUi5wcm9wKCd2YWx1ZScpKTtcclxuICAgICAgICBpZiAocmF3TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3Nbc2V0dGluZ3NQYXRoXS5uYW1lID0gbmFtZXNbMF0udmFsdWU7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lc1swXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMudXBkYXRlRW50aXR5U2V0dGluZyA9IChzZXR0aW5nc1BhdGgsIG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IERCTVMuZ2V0U2V0dGluZ3MoKTtcclxuICAgICAgICBpZihzZXR0aW5nc1tzZXR0aW5nc1BhdGhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3Nbc2V0dGluZ3NQYXRoXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR0aW5nc1tzZXR0aW5nc1BhdGhdLm5hbWUgPSBuYW1lO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5zY3JvbGxUbyA9IChjb250YWluZXIsIGVsZW1lbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkb21SZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xyXG4gICAgICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IGNvbnRhaW5lci5zY3JvbGxUb3AgKyBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGVsZW1lbnQub2Zmc2V0VG9wIDwgc2Nyb2xsVG9wIHx8IChlbGVtZW50Lm9mZnNldFRvcCArIGRvbVJlY3QuaGVpZ2h0KSA+IHNjcm9sbEJvdHRvbTtcclxuICAgICAgICBcclxuICAgICAgICBpZihjb25kaXRpb24pe1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gY29udGFpbmVyLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgY29uc3QgdG8gPSBlbGVtZW50Lm9mZnNldFRvcCAtIGNvbnRhaW5lci5jbGllbnRIZWlnaHQvMiArIGRvbVJlY3QuaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBVdGlscy5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgICAgICB0aW1pbmc6IFRpbWluZy5tYWtlRWFzZUluT3V0KFRpbWluZy5wb2x5KDQpKSxcclxuICAgICAgICAgICAgICAgIGRyYXc6IGZ1bmN0aW9uKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSh0aGlzLlVJID0ge30pO1xyXG4iLCIvKkNvcHlyaWdodCAyMDE1LTIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT4sIE1hcmlhIFNpZGVraG1lbm92YSA8bWF0aWxkYV9AbGlzdC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUT0RPIG5lZWQgdG8gbGludCB1dGlscyB3aXRoIE5JTVMgZml4ZXNcclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuXHJcbmNvbnN0IHN0ckZvcm1hdCA9IFIuY3VycnkoQ29tbW9uVXRpbHMuc3RyRm9ybWF0KTtcclxuXHJcbmZ1bmN0aW9uIGdldEwxMG4oa2V5KSB7XHJcbiAgICByZXR1cm4gTDEwbi5nZXRWYWx1ZShrZXkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdEwxMG4oa2V5KSB7XHJcbiAgICByZXR1cm4gTDEwbi5nZXRWYWx1ZShgY29uc3RhbnQtJHtrZXl9YCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcclxufVxyXG5cclxuY29uc3QgYWRkQ2xhc3MgPSBSLmN1cnJ5KChvLCBjKSA9PiB7XHJcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYChefFxcXFxzKSR7Y30oXFxcXHN8JClgLCAnZycpO1xyXG4gICAgaWYgKHJlLnRlc3Qoby5jbGFzc05hbWUpKSByZXR1cm4gbztcclxuICAgIG8uY2xhc3NOYW1lID0gKGAke28uY2xhc3NOYW1lfSAke2N9YCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoLyheIHwgJCkvZywgJycpO1xyXG4gICAgcmV0dXJuIG87XHJcbn0pO1xyXG5cclxuY29uc3QgYWRkQ2xhc3NlcyA9IFIuY3VycnkoKG8sIGMpID0+IHtcclxuICAgIFIuYXAoW2FkZENsYXNzKG8pXSwgYyk7XHJcbiAgICByZXR1cm4gbztcclxufSk7XHJcblxyXG5jb25zdCBoYXNDbGFzcyA9IFIuY3VycnkoKG8sIGMpID0+IHtcclxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtjfShcXFxcc3wkKWAsICdnJyk7XHJcbiAgICByZXR1cm4gKHJlLnRlc3Qoby5jbGFzc05hbWUpKTtcclxufSk7XHJcblxyXG5jb25zdCByZW1vdmVDbGFzcyA9IFIuY3VycnkoKG8sIGMpID0+IHtcclxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtjfShcXFxcc3wkKWAsICdnJyk7XHJcbiAgICBvLmNsYXNzTmFtZSA9IG8uY2xhc3NOYW1lLnJlcGxhY2UocmUsICckMScpLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC8oXiB8ICQpL2csICcnKTtcclxuICAgIHJldHVybiBvO1xyXG59KTtcclxuXHJcbmNvbnN0IHJlbW92ZUNsYXNzZXMgPSBSLmN1cnJ5KChvLCBjKSA9PiB7XHJcbiAgICBSLmFwKFtyZW1vdmVDbGFzcyhvKV0sIGMpO1xyXG4gICAgcmV0dXJuIG87XHJcbn0pO1xyXG5cclxuY29uc3QgdG9nZ2xlQ2xhc3MgPSBSLmN1cnJ5KChvLCBjKSA9PiB7XHJcbiAgICBpZiAoaGFzQ2xhc3MobywgYykpIHtcclxuICAgICAgICByZW1vdmVDbGFzcyhvLCBjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkQ2xhc3MobywgYyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY29uc3Qgc2V0Q2xhc3NCeUNvbmRpdGlvbiA9IFIuY3VycnkoKG8sIGMsIGNvbmRpdGlvbikgPT4ge1xyXG4gICAgaWYgKGNvbmRpdGlvbikge1xyXG4gICAgICAgIGFkZENsYXNzKG8sIGMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZW1vdmVDbGFzcyhvLCBjKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvO1xyXG59KTtcclxuXHJcbmNvbnN0IHNldENsYXNzSWYgPSBzZXRDbGFzc0J5Q29uZGl0aW9uO1xyXG5cclxuY29uc3Qgc2hvd0VsID0gKGVsLCBjb25kaXRpb24pID0+IHNldENsYXNzQnlDb25kaXRpb24oZWwsICdoaWRkZW4nLCAhY29uZGl0aW9uKTtcclxuY29uc3QgaGlkZUVsID0gKGVsLCBjb25kaXRpb24pID0+IHNldENsYXNzQnlDb25kaXRpb24oZWwsICdoaWRkZW4nLCBjb25kaXRpb24pO1xyXG5cclxuZnVuY3Rpb24gZ2V0RWwoaWQpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5RWwoc2VsKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWwpO1xyXG59XHJcblxyXG5jb25zdCBxZSA9IHF1ZXJ5RWw7XHJcblxyXG4vLyBxdWVyeSB0ZW1wbGF0ZSBlbGVtZW50XHJcbmZ1bmN0aW9uIHF0ZShzZWwpe1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsKS5jb250ZW50LmNsb25lTm9kZSh0cnVlKTtcclxufVxyXG5cclxuLy8gcXVlcnkgbWF0ZXJpYWxpemUgdGVtcGxhdGUgZWxlbWVudFxyXG5mdW5jdGlvbiBxbXRlKHNlbCl7XHJcbiAgICByZXR1cm4gYWRkRWwobWFrZUVsKCdkaXYnKSwgcXRlKHNlbCkpLmZpcnN0Q2hpbGQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5RWxzKHNlbCkge1xyXG4gICAgcmV0dXJuIG5sMmFycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKSk7XHJcbn1cclxuXHJcbmNvbnN0IHFlcyA9IHF1ZXJ5RWxzO1xyXG5cclxuZnVuY3Rpb24gcXVlcnlFbEVsKGVsLCBzZWwpIHtcclxuICAgIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHNlbCk7XHJcbn1cclxuXHJcbmNvbnN0IHFlZSA9IFIuY3VycnkocXVlcnlFbEVsKTtcclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5RWxFbHMoZWwsIHNlbCkge1xyXG4gICAgcmV0dXJuIG5sMmFycmF5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKSk7XHJcbn1cclxuXHJcbmNvbnN0IHFlZXMgPSBSLmN1cnJ5KHF1ZXJ5RWxFbHMpO1xyXG5cclxuZnVuY3Rpb24gZ2V0RWxzKGNsYXp6KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGF6eik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VFbChlbFRhZykge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxUYWcpO1xyXG59XHJcblxyXG5jb25zdCB3cmFwRWwgPSBSLmN1cnJ5KChlbFRhZywgZWwpID0+IHtcclxuICAgIHJldHVybiBhZGRFbChtYWtlRWwoZWxUYWcpLCBlbCk7XHJcbn0pXHJcblxyXG5jb25zdCB3cmFwRWxzID0gUi5jdXJyeSgoZWxUYWcsIGVscykgPT4ge1xyXG4gICAgcmV0dXJuIGFkZEVscyhtYWtlRWwoZWxUYWcpLCBlbHMpO1xyXG59KVxyXG5cclxuZnVuY3Rpb24gbWFrZVRleHQodGV4dCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xyXG59XHJcblxyXG5jb25zdCBhZGRFbCA9IFIuY3VycnkoKHBhcmVudCwgY2hpbGQpID0+IHtcclxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbiAgICByZXR1cm4gcGFyZW50O1xyXG59KTtcclxuY29uc3QgYWRkRWxzID0gUi5jdXJyeSgocGFyZW50LCBjaGlsZHJlbikgPT4ge1xyXG4gICAgUi5hcChbYWRkRWwocGFyZW50KV0sIGNoaWxkcmVuKTtcclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbn0pO1xyXG5cclxuY29uc3QgbWFrZU9wdCA9IGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgY29uc3Qgb3B0aW9uID0gbWFrZUVsKCdvcHRpb24nKTtcclxuICAgIGFkZEVsKG9wdGlvbiwgKG1ha2VUZXh0KGxhYmVsKSkpO1xyXG4gICAgcmV0dXJuIG9wdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHNldEF0dHIgPSBSLmN1cnJ5KChlbCwgbmFtZSwgdmFsdWUpID0+IHtcclxuICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn0pO1xyXG5cclxuY29uc3Qgc2V0U3R5bGUgPSBSLmN1cnJ5KChlbCwgbmFtZSwgdmFsdWUpID0+IHtcclxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcclxuICAgIHJldHVybiBlbDtcclxufSk7XHJcblxyXG5jb25zdCBzZXRJbXBvcnRhbnRTdHlsZSA9IFIuY3VycnkoKGVsLCBuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsICdpbXBvcnRhbnQnKTtcclxuICAgIHJldHVybiBlbDtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBkZWxBdHRyKGVsLCBuYW1lKSB7XHJcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuXHJcbmNvbnN0IGdldEF0dHIgPSBSLmN1cnJ5KChlbCwgbmFtZSkgPT4ge1xyXG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcclxufSk7XHJcblxyXG5jb25zdCBzZXRQcm9wID0gUi5jdXJyeSgoZWwsIGtleSwgdmFsdWUpID0+IHtcclxuICAgIGVsW2tleV0gPSB2YWx1ZTtcclxuICAgIHJldHVybiBlbDtcclxufSk7XHJcblxyXG5jb25zdCBzZXRQcm9wcyA9IFIuY3VycnkoKGVsLCBtYXApID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xyXG4gICAgICAgIHNldFByb3AoZWwsIGtleSwgbWFwW2tleV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFyRWwoZWwpIHtcclxuICAgIFV0aWxzLnJlbW92ZUNoaWxkcmVuKGVsKTtcclxuICAgIHJldHVybiBlbDtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYXJFbHMoZWxzKXtcclxuICAgIHJldHVybiBlbHMubWFwKGNsZWFyRWwpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhc3NFbHMoc3JjLCBkc3QpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYWRkRWwoZHN0LCBzcmMuY2hpbGRyZW5baV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBsaXN0ZW4gPSBSLmN1cnJ5KChlbCwgZXZlbnQsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICByZXR1cm4gZWw7XHJcbn0pO1xyXG5cclxuY29uc3QgbGlzdGVuT25FbnRlciA9IFIuY3VycnkoKGVsLCBjYWxsYmFjaykgPT4ge1xyXG4gICAgbGlzdGVuKGVsLCAna2V5ZG93bicsIChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgaWYoZS5pQW1Ob3RBbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPaCBkZWFyIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUuaUFtTm90QWxvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5jb25zdCBmaWxsU2VsZWN0b3IgPSBSLmN1cnJ5KChzZWwsIGRhdGEpID0+IGFkZEVscyhzZWwsIGRhdGEubWFwKChpdGVtKSA9PiB7XHJcbiAgICBjb25zdCBvcHQgPSBtYWtlRWwoJ29wdGlvbicpO1xyXG4gICAgYWRkRWwob3B0LCBtYWtlVGV4dChpdGVtLm5hbWUpKTtcclxuICAgIGlmIChpdGVtLnZhbHVlICE9PSB1bmRlZmluZWQpIHsgb3B0LnZhbHVlID0gaXRlbS52YWx1ZTsgfVxyXG4gICAgaWYgKGl0ZW0uc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkgeyBvcHQuc2VsZWN0ZWQgPSB0cnVlOyB9XHJcbiAgICBpZiAoaXRlbS5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCkgeyBhZGRDbGFzcyhvcHQsIGl0ZW0uY2xhc3NOYW1lKTsgfVxyXG4gICAgcmV0dXJuIG9wdDtcclxufSkpKTtcclxuXHJcbmZ1bmN0aW9uIG5sMmFycmF5KG5vZGVMaXN0KSB7XHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xyXG59XHJcblxyXG5jb25zdCByZW1hcFByb3BzID0gUi5jdXJyeSgob3V0S2V5cywgcGlja0tleXMsIG9iaikgPT4gUi5jb21wb3NlKFIuemlwT2JqKG91dEtleXMpLCBSLnZhbHVlcywgUi5waWNrKHBpY2tLZXlzKSkob2JqKSk7XHJcblxyXG5jb25zdCByZW1hcFByb3BzNFNlbGVjdDIgPSByZW1hcFByb3BzKFsnaWQnLCAndGV4dCddLCBbJ3ZhbHVlJywgJ2Rpc3BsYXlOYW1lJ10pO1xyXG5jb25zdCByZW1hcFByb3BzNFNlbGVjdCA9IHJlbWFwUHJvcHMoWyd2YWx1ZScsICduYW1lJ10sIFsndmFsdWUnLCAnZGlzcGxheU5hbWUnXSk7XHJcblxyXG5jb25zdCBnZXRTZWxlY3QyRGF0YUNvbW1vbiA9IFIuY3VycnkoKHByZXBhcmF0b3IsIG9iaikgPT4gUi5jb21wb3NlKFIuemlwT2JqKFsnZGF0YSddKSwgUi5hcHBlbmQoUi5fXywgW10pLCBSLm1hcChwcmVwYXJhdG9yKSkob2JqKSk7XHJcblxyXG5jb25zdCBnZXRTZWxlY3QyRGF0YSA9IGdldFNlbGVjdDJEYXRhQ29tbW9uKHJlbWFwUHJvcHM0U2VsZWN0Mik7XHJcblxyXG5jb25zdCBtYWtlU2VsZWN0Mk9wdCA9IFIuY29tcG9zZShSLnppcE9iaihbJ2lkJywgJ3RleHQnXSksIFIucmVwZWF0KFIuX18sIDIpKTtcclxuY29uc3QgYXJyMlNlbGVjdDIgPSBSLmNvbXBvc2UoUi5hc3NvYygnZGF0YScsIFIuX18sIHt9KSwgUi5tYXAobWFrZVNlbGVjdDJPcHQpKTtcclxuY29uc3QgYXJyMlNlbGVjdCA9IFIubWFwKFIuY29tcG9zZShSLnppcE9iaihbJ3ZhbHVlJywgJ25hbWUnXSksIFIucmVwZWF0KFIuX18sIDIpKSk7XHJcbmNvbnN0IGNvbnN0QXJyMlNlbGVjdCA9IFIubWFwKFIuY29tcG9zZShSLnppcE9iaihbJ3ZhbHVlJywgJ25hbWUnXSksIG5hbWUgPT4gW25hbWUsIGNvbnN0TDEwbihuYW1lKV0pKTtcclxuXHJcbmNvbnN0IGdldFNlbGVjdGVkUmFkaW8gPSBmdW5jdGlvbiAoZWwsIHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gcXVlcnlFbEVscyhlbCwgcXVlcnkpLmZpbmQoUi5wcm9wKCdjaGVja2VkJykpO1xyXG59O1xyXG5cclxuY29uc3QgZGVidWdJbnRlcmNlcHRvciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShhcmd1bWVudHNbMF0pKTtcclxuICAgICAgICBjYWxsYmFjayguLi5hcmd1bWVudHMpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbmNvbnN0IFV0aWxzID0ge307XHJcblxyXG4vKiogb3B0c1xyXG4gICAgdG9vbHRpcCAtIGFkZCB0b29sdGlwIHRvIGJ1dHRvbiwgdXNlZCBmb3IgaWNvbmljIGJ1dHRvbnNcclxuICAgIGlkIC0gc2V0IGJ1dHRvbiBpZFxyXG4gICAgbWFpblBhZ2UgLSBlbmFibGUgdmlldyBhcyBmaXJzdCBwYWdlIC0gZGVwcmVjYXRlZC4gVXNlIFV0aWxzLnNldEZpcnN0VGFiIGluc3RlYWRcclxuICAgIHRvZ2dsZSAtIHRvZ2dsZSBjb250ZW50LCBhc3NvY2lhdGVkIHdpdGggYnV0dG9uXHJcbiovXHJcblV0aWxzLmFkZFZpZXcgPSBmdW5jdGlvbiAoY29udGFpbmVycywgbmFtZSwgdmlldywgb3B0czIpIHtcclxuICAgIGNvbnN0IG9wdHMgPSBvcHRzMiB8fCB7fTtcclxuICAgIHZpZXcuaW5pdCgpO1xyXG4gICAgY29uc3QgYnV0dG9uQ2xhc3MgPSAnbmF2aWdhdGlvbi1idXR0b24nO1xyXG4gICAgY29udGFpbmVycy5yb290LnZpZXdzW25hbWVdID0gdmlldztcclxuICAgIGNvbnN0IGJ1dHRvbiA9IG1ha2VFbCgnYnV0dG9uJyk7XHJcbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZSgpIHtcclxuICAgICAgICAkKGJ1dHRvbikuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsIEwxMG4uZ2V0VmFsdWUoYGhlYWRlci0ke25hbWV9YCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMudG9vbHRpcCkge1xyXG4gICAgICAgIEwxMG4ub25MMTBuQ2hhbmdlKGRlbGVnYXRlKTtcclxuICAgICAgICAkKGJ1dHRvbikudG9vbHRpcCh7XHJcbiAgICAgICAgICAgIHRpdGxlOiBMMTBuLmdldFZhbHVlKGBoZWFkZXItJHtuYW1lfWApLFxyXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkZEVsKGJ1dHRvbiwgbWFrZVRleHQoTDEwbi5nZXRWYWx1ZShgaGVhZGVyLSR7bmFtZX1gKSkpO1xyXG4gICAgICAgIHNldEF0dHIoYnV0dG9uLCAnbDEwbi1pZCcsIGBoZWFkZXItJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgYWRkQ2xhc3MoYnV0dG9uLCBidXR0b25DbGFzcyk7XHJcbiAgICBhZGRDbGFzcyhidXR0b24sIGAtdGVzdC0ke25hbWV9YCk7XHJcbiAgICBhZGRDbGFzcyhidXR0b24sIGAtdG9nZ2xlLWNsYXNzLSR7bmFtZX1gKTtcclxuICAgIGlmIChvcHRzLmNsYXp6KSB7XHJcbiAgICAgICAgYWRkQ2xhc3MoYnV0dG9uLCBvcHRzLmNsYXp6KTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5lcnMubmF2aWdhdGlvbi5hcHBlbmRDaGlsZChidXR0b24pO1xyXG5cclxuICAgIGNvbnN0IG9uQ2xpY2tEZWxlZ2F0ZSA9IGZ1bmN0aW9uICh2aWV3Mikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgIC8vVGVzdHMucnVuKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1zID0gY29udGFpbmVycy5uYXZpZ2F0aW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnV0dG9uQ2xhc3MpO1xyXG4gICAgICAgICAgICBpZiAob3B0cy50b2dnbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVscyA9IGdldEVscyhgLXRvZ2dsZS1jbGFzcy0ke25hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQudGFyZ2V0LmlzRXF1YWxOb2RlKGVsc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyhlbHNbaV0sICdhY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNbaV0uY2xpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gaGFzQ2xhc3MoZXZ0LnRhcmdldCwgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtc1tpXSwgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0cy50b2dnbGUgfHwgKG9wdHMudG9nZ2xlICYmICFpc0FjdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGV2dC50YXJnZXQsICdhY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXNzRWxzKGNvbnRhaW5lcnMuY29udGVudCwgZ2V0RWwoJ3dhcmVob3VzZScpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMuY29udGVudC5hcHBlbmRDaGlsZCh2aWV3Mi5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGNvbnRhaW5lcnMuY29udGVudCwgJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVycy5yb290LmN1cnJlbnRWaWV3ID0gdmlldzI7XHJcbiAgICAgICAgICAgICAgICB2aWV3Mi5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhldnQudGFyZ2V0LCAnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICBwYXNzRWxzKGNvbnRhaW5lcnMuY29udGVudCwgZ2V0RWwoJ3dhcmVob3VzZScpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMucm9vdC5jdXJyZW50VmlldyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhjb250YWluZXJzLmNvbnRlbnQsICdoaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tEZWxlZ2F0ZSh2aWV3KSk7XHJcblxyXG4gICAgLy8gZGVwcmVjYXRlZC4gVXNlIFV0aWxzLnNldEZpcnN0VGFiIGluc3RlYWRcclxuICAgIGlmIChvcHRzLm1haW5QYWdlKSB7XHJcbiAgICAgICAgVXRpbHMuc2V0Rmlyc3RUYWIoY29udGFpbmVycywge2J1dHRvbiwgdmlld30pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtidXR0b24sIHZpZXd9O1xyXG59O1xyXG5cclxuVXRpbHMuc2V0Rmlyc3RUYWIgPSBmdW5jdGlvbihjb250YWluZXJzLCBvcHRzKXtcclxuICAgIGFkZENsYXNzKG9wdHMuYnV0dG9uLCAnYWN0aXZlJyk7XHJcbiAgICBjb250YWluZXJzLmNvbnRlbnQuYXBwZW5kQ2hpbGQob3B0cy52aWV3LmNvbnRlbnQpO1xyXG4gICAgY29udGFpbmVycy5yb290LmN1cnJlbnRWaWV3ID0gb3B0cy52aWV3O1xyXG59XHJcblxyXG5VdGlscy5hbGVydCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICB2ZXguZGlhbG9nLmFsZXJ0KG1lc3NhZ2UpO1xyXG59O1xyXG5cclxuY29uc3Qgc2V0RXJyb3IgPSAoZWwsIGVycikgPT4gYWRkRWwoY2xlYXJFbChxZWUoZWwsICcuZXJyb3ItbXNnJykpLCBtYWtlVGV4dChVdGlscy5oYW5kbGVFcnJvck1zZyhlcnIpKSk7XHJcbmNvbnN0IGNsZWFyRXJyb3IgPSAoZWwpID0+IGNsZWFyRWwocWVlKGVsLCAnLmVycm9yLW1zZycpKTtcclxuXHJcblV0aWxzLmNvbmZpcm0gPSBmdW5jdGlvbiAobWVzc2FnZSwgb25Paywgb25DYW5jZWwpIHtcclxuICAgIHZleC5kaWFsb2cuY29uZmlybSh7XHJcbiAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICBjYWxsYmFjazogKHZhbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob25Paykgb25PaygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9uQ2FuY2VsKSBvbkNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuVXRpbHMucmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbiAobXlOb2RlKSB7XHJcbiAgICBpZiAoIW15Tm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHdoaWxlIChteU5vZGUuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgIG15Tm9kZS5yZW1vdmVDaGlsZChteU5vZGUuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5VdGlscy5wcm9jZXNzRXJyb3IgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICBVdGlscy5oYW5kbGVFcnJvcihlcnIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFycik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcblV0aWxzLmhhbmRsZUVycm9yTXNnID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgY29uc3QgY2hlY2tFcnJvclR5cGUgPSBSLmN1cnJ5KChlcnIyLCBuYW1lKSA9PiBlcnIyIGluc3RhbmNlb2YgRXJyb3JzW25hbWVdIHx8IChlcnIyLm5hbWUgJiYgZXJyMi5uYW1lID09PSBuYW1lKSk7XHJcbiAgICBpZiAoUi5rZXlzKEVycm9ycykuc29tZShjaGVja0Vycm9yVHlwZShlcnIpKSkge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGVyci5wYXJhbWV0ZXJzLm1hcCh2YWwgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gTDEwbi5oYXNWYWx1ZSh2YWwpID8gTDEwbi5nZXRWYWx1ZSh2YWwpIDogdmFsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzdHJGb3JtYXQoZ2V0TDEwbihlcnIubWVzc2FnZUlkKSwgcGFyYW1zKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gZXJyLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXJyO1xyXG59O1xyXG5cclxuVXRpbHMuaGFuZGxlRXJyb3IgPSBlcnIgPT4gVXRpbHMuYWxlcnQoVXRpbHMuaGFuZGxlRXJyb3JNc2coZXJyKSk7XHJcblxyXG5VdGlscy5lbmFibGVFbCA9IFIuY3VycnkoKGVsLCBjb25kaXRpb24pID0+IHtcclxuICAgIGNvbnN0IGtleSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJyA/ICdyZWFkb25seScgOiAnZGlzYWJsZWQnO1xyXG4gICAgaWYgKGNvbmRpdGlvbikge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblV0aWxzLmVuYWJsZSA9IGZ1bmN0aW9uIChyb290LCBjbGFzc05hbWUsIGNvbmRpdGlvbikge1xyXG4gICAgbmwyYXJyYXkocm9vdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSkpLm1hcChVdGlscy5lbmFibGVFbChSLl9fLCBjb25kaXRpb24pKTtcclxufTtcclxuXHJcblV0aWxzLmNoYXJPcmRBT2JqZWN0ID0gQ29tbW9uVXRpbHMuY2hhck9yZEFGYWN0b3J5KGEgPT4gYS5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpKTtcclxuXHJcblV0aWxzLnJlYnVpbGRTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbmFtZXMpIHtcclxuICAgIGNsZWFyRWwoc2VsZWN0b3IpO1xyXG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZUluZm8pID0+IHtcclxuICAgICAgICBjb25zdCBvcHRpb24gPSBtYWtlRWwoJ29wdGlvbicpO1xyXG4gICAgICAgIG9wdGlvbi5hcHBlbmRDaGlsZChtYWtlVGV4dChuYW1lSW5mby5kaXNwbGF5TmFtZSkpO1xyXG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IG5hbWVJbmZvLnZhbHVlO1xyXG4gICAgICAgIHNlbGVjdG9yLmFwcGVuZENoaWxkKG9wdGlvbik7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblV0aWxzLnJlYnVpbGRTZWxlY3RvckFyciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbmFtZXMpIHtcclxuICAgIGNsZWFyRWwoc2VsZWN0b3IpO1xyXG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IG1ha2VFbCgnb3B0aW9uJyk7XHJcbiAgICAgICAgb3B0aW9uLmFwcGVuZENoaWxkKG1ha2VUZXh0KG5hbWUpKTtcclxuICAgICAgICBzZWxlY3Rvci5hcHBlbmRDaGlsZChvcHRpb24pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vLyBmcm9tIGh0dHBzOi8vbGVhcm4uamF2YXNjcmlwdC5ydS9qcy1hbmltYXRpb25cclxuVXRpbHMuYW5pbWF0ZSA9IChvcHRpb25zKSA9PiB7XHJcbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcclxuICAgICAgICAvLyB0aW1lRnJhY3Rpb24gZnJvbSAwIHRvIDFcclxuICAgICAgICBsZXQgdGltZUZyYWN0aW9uID0gKHRpbWUgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xyXG4gICAgICAgIGlmICh0aW1lRnJhY3Rpb24gPiAxKSB0aW1lRnJhY3Rpb24gPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlXHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBvcHRpb25zLnRpbWluZyh0aW1lRnJhY3Rpb24pXHJcbiAgICAgICAgXHJcbiAgICAgICAgb3B0aW9ucy5kcmF3KHByb2dyZXNzKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGltZUZyYWN0aW9uIDwgMSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmNvbnN0IFRpbWluZyA9IHt9O1xyXG5cclxuLy8gY2FsbCBleGFtcGxlc1xyXG4vL3RpbWluZzogVGltaW5nLmxpbmVhcixcclxuLy90aW1pbmc6IFRpbWluZy5xdWFkLFxyXG4vL3RpbWluZzogVGltaW5nLmNpcmMsXHJcbi8vdGltaW5nOiBUaW1pbmcuYm91bmNlLFxyXG4vL3RpbWluZzogVGltaW5nLm1ha2VFYXNlT3V0KFRpbWluZy5ib3VuY2UpLFxyXG4vL3RpbWluZzogVGltaW5nLm1ha2VFYXNlSW5PdXQoVGltaW5nLmJvdW5jZSksXHJcbi8vdGltaW5nOiBUaW1pbmcuYmFjaygzLjUpLFxyXG4vL3RpbWluZzogVGltaW5nLmVsYXN0aWMoMS41KSxcclxuLy90aW1pbmc6IFRpbWluZy5tYWtlRWFzZUluT3V0KFRpbWluZy5wb2x5KDQpKSxcclxuXHJcblRpbWluZy5saW5lYXIgPSAodGltZUZyYWN0aW9uKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZUZyYWN0aW9uO1xyXG59XHJcblxyXG5UaW1pbmcucXVhZCA9ICggcHJvZ3Jlc3MpID0+IHtcclxuICAgIHJldHVybiBNYXRoLnBvdyhwcm9ncmVzcywgMilcclxufVxyXG5cclxuVGltaW5nLnBvbHkgPSBSLmN1cnJ5KCh4LCBwcm9ncmVzcykgPT4ge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KHByb2dyZXNzLCB4KVxyXG59KVxyXG5cclxuVGltaW5nLmNpcmMgPSAodGltZUZyYWN0aW9uKSA9PiB7XHJcbiAgICByZXR1cm4gMSAtIE1hdGguc2luKE1hdGguYWNvcyh0aW1lRnJhY3Rpb24pKVxyXG59XHJcblxyXG5UaW1pbmcuYmFjayA9IFIuY3VycnkoKHgsIHRpbWVGcmFjdGlvbikgPT4ge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KHRpbWVGcmFjdGlvbiwgMikgKiAoKHggKyAxKSAqIHRpbWVGcmFjdGlvbiAtIHgpXHJcbn0pXHJcblxyXG5UaW1pbmcuYm91bmNlID0gKHRpbWVGcmFjdGlvbikgPT4ge1xyXG4gICAgZm9yICh2YXIgYSA9IDAsIGIgPSAxLCByZXN1bHQ7IDE7IGEgKz0gYiwgYiAvPSAyKSB7XHJcbiAgICAgICAgaWYgKHRpbWVGcmFjdGlvbiA+PSAoNyAtIDQgKiBhKSAvIDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtTWF0aC5wb3coKDExIC0gNiAqIGEgLSAxMSAqIHRpbWVGcmFjdGlvbikgLyA0LCAyKSArIE1hdGgucG93KGIsIDIpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5UaW1pbmcuZWxhc3RpYyA9ICh4LCB0aW1lRnJhY3Rpb24pID0+IHtcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh0aW1lRnJhY3Rpb24gLSAxKSkgKiBNYXRoLmNvcygyMCAqIE1hdGguUEkgKiB4IC8gMyAqIHRpbWVGcmFjdGlvbilcclxufVxyXG5cclxuVGltaW5nLm1ha2VFYXNlT3V0ID0gKHRpbWluZykgPT4ge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRpbWVGcmFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAxIC0gdGltaW5nKDEgLSB0aW1lRnJhY3Rpb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG5UaW1pbmcubWFrZUVhc2VJbk91dCA9ICh0aW1pbmcpID0+IHtcclxuICAgIHJldHVybiBmdW5jdGlvbih0aW1lRnJhY3Rpb24pIHtcclxuICAgICAgICBpZiAodGltZUZyYWN0aW9uIDwgLjUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRpbWluZygyICogdGltZUZyYWN0aW9uKSAvIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICgyIC0gdGltaW5nKDIgKiAoMSAtIHRpbWVGcmFjdGlvbikpKSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5TdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24gKHN1ZmZpeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzdWZmaXgsIHRoaXMubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xyXG59O1xyXG5cclxuLy8gZnJvbSBkYXRlIGZvcm1hdCB1dGlsc1xyXG4vL0ZvciBjb252ZW5pZW5jZS4uLlxyXG5EYXRlLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobWFzaywgdXRjKSB7XHJcbiAgICByZXR1cm4gZGF0ZUZvcm1hdCh0aGlzLCBtYXNrLCB1dGMpO1xyXG59O1xyXG4iLCIvKkNvcHlyaWdodCAyMDE1LCAyMDE4IFRpbW9mZXkgUmVjaGthbG92IDxudHNka0B5YW5kZXgucnU+LCBNYXJpYSBTaWRla2htZW5vdmEgPG1hdGlsZGFfQGxpc3QucnU+XHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLiAqL1xyXG5cclxuLypnbG9iYWxcclxuVXRpbHMsIE92ZXJ2aWV3LCBQcm9maWxlcywgU3RvcmllcywgQWRhcHRhdGlvbnMsIEJyaWVmaW5ncywgVGltZWxpbmUsIFNvY2lhbE5ldHdvcmssIEZpbGVVdGlsc1xyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7fTtcclxuICAgIHN0YXRlLnZpZXdzID0ge307XHJcbiAgICBzdGF0ZS5maXJzdEJhc2VMb2FkID0gTU9ERSA9PT0gJ1N0YW5kYWxvbmUnO1xyXG4gICAgXHJcbiAgICBjb25zdCBCQUNLVVBfTlVNQkVSID0gNDtcclxuICAgIGNvbnN0IEJBQ0tVUF9JTlRFUlZBTCA9IDYwMDAwKjEwOyAvLyAxMCBtaW5cclxuXHJcbiAgICBjb25zdCBidG5PcHRzID0ge1xyXG4gICAgICAgIHRvb2x0aXA6IHRydWUsXHJcbiAgICAgICAgY2xhc3NOYW1lOiAnbWFpbk5hdkJ1dHRvbidcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaW5pdFBhZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgTDEwbi5pbml0KCk7XHJcbiAgICAgICAgTDEwbi5vbkwxMG5DaGFuZ2UoKCkgPT4gc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpKTtcclxuICAgICAgICBVSS5pbml0U2VsZWN0b3JGaWx0ZXJzKCk7XHJcbiAgICAgICAgVUkuaW5pdFBhbmVsVG9nZ2xlcnMoKTtcclxuICAgICAgICBMMTBuLmxvY2FsaXplU3RhdGljKCk7XHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlRGlhbG9ncygpIHtcclxuICAgICAgICAgICAgdmV4LmRpYWxvZy5idXR0b25zLllFUy50ZXh0ID0gZ2V0TDEwbignY29tbW9uLW9rJyk7XHJcbiAgICAgICAgICAgIHZleC5kaWFsb2cuYnV0dG9ucy5OTy50ZXh0ID0gZ2V0TDEwbignY29tbW9uLWNhbmNlbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVEaWFsb2dzKCk7XHJcbiAgICAgICAgTDEwbi5vbkwxMG5DaGFuZ2UodXBkYXRlRGlhbG9ncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHByb3RvRXhwYW5kZXIgPSAoYXJyKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gcHJvdG9DYXJyaWVyKCkge31cclxuICAgICAgICBhcnIuZm9yRWFjaChuYW1lID0+IChwcm90b0NhcnJpZXIucHJvdG90eXBlW25hbWVdID0gKCgpID0+IDEpKSk7XHJcbiAgICAgICAgcmV0dXJuIHByb3RvQ2FycmllcjtcclxuICAgIH07XHJcbiAgICBjb25zdCBwbGF5ZXJBcnIgPSBbXHJcbiAgICAgICAgJ2dldFBsYXllcnNPcHRpb25zJyxcclxuICAgICAgICAnZ2V0V2VsY29tZVRleHQnLFxyXG4gICAgICAgICdnZXRQbGF5ZXJQcm9maWxlSW5mbycsXHJcbiAgICAgICAgJ2NyZWF0ZUNoYXJhY3RlckJ5UGxheWVyJyxcclxuICAgICAgICAndXBkYXRlUHJvZmlsZUZpZWxkJyxcclxuICAgICAgICAnZ2V0Um9sZUdyaWRJbmZvJ107XHJcblxyXG4gICAgZXhwb3J0cy5yZWZyZXNoID0gKCkgPT4gc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpO1xyXG5cclxuICAgIGV4cG9ydHMub25QbGF5ZXJQYWdlTG9hZCA9ICgpID0+IHtcclxuICAgICAgICBpbml0UGFnZSgpO1xyXG4gICAgICAgIGNvbnN0IFJlbW90ZURCTVMgPSBtYWtlUmVtb3RlREJNUyhwcm90b0V4cGFuZGVyKHBsYXllckFycikpO1xyXG4gICAgICAgIHdpbmRvdy5EQk1TID0gbmV3IFJlbW90ZURCTVMoKTtcclxuICAgICAgICBzdGF0ZUluaXQoKTtcclxuICAgICAgICBVdGlscy5hZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICdwbGF5ZXInLCBQbGF5ZXIsIHsgbWFpblBhZ2U6IHRydWUgfSk7XHJcbiAgICAgICAgYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgYWRkQ2xhc3MobWFrZUVsKCdkaXYnKSwgJ25hdi1zZXBhcmF0b3InKSk7XHJcbiAgICAgICAgVXRpbHMuYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnYWJvdXQnLCBBYm91dCk7XHJcbiAgICAgICAgLy8gICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VMMTBuQnV0dG9uKCkpO1xyXG4gICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ2xvZ291dEJ1dHRvbiBpY29uLWJ1dHRvbicsICdsb2dvdXQnLCBwb3N0TG9nb3V0LCBidG5PcHRzKSk7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLm9uSW5kZXhQYWdlTG9hZCA9ICgpID0+IHtcclxuICAgICAgICBpbml0UGFnZSgpO1xyXG4gICAgICAgIGNvbnN0IFJlbW90ZURCTVMgPSBtYWtlUmVtb3RlREJNUyhwcm90b0V4cGFuZGVyKFsnZ2V0UGxheWVyc09wdGlvbnMnLCAnZ2V0Um9sZUdyaWRJbmZvJ10pKTtcclxuICAgICAgICB3aW5kb3cuREJNUyA9IG5ldyBSZW1vdGVEQk1TKCk7XHJcbiAgICAgICAgc3RhdGVJbml0KCk7XHJcbiAgICAgICAgREJNUy5nZXRQbGF5ZXJzT3B0aW9ucygoZXJyLCBwbGF5ZXJzT3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBhZGRDbGFzcyhtYWtlRWwoJ2RpdicpLCAnbmF2LXNlcGFyYXRvcicpKTtcclxuICAgICAgICAgICAgVXRpbHMuYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnZW50ZXInLCBFbnRlciwgeyBtYWluUGFnZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgaWYgKHBsYXllcnNPcHRpb25zLmFsbG93UGxheWVyQ3JlYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ3NpZ24tdXAnLCBTaWduVXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFV0aWxzLmFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ2Fib3V0JywgQWJvdXQpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VMMTBuQnV0dG9uKCkpO1xyXG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50Vmlldy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHBvcnRzLm9uT3JnYW5pemVyUGFnZUxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgaW5pdFBhZ2UoKTtcclxuICAgICAgICBjb25zdCBMb2NhbERCTVMgPSBtYWtlTG9jYWxEQk1TKHRydWUpO1xyXG4gICAgICAgIGlmIChNT0RFID09PSAnU3RhbmRhbG9uZScpIHtcclxuICAgICAgICAgICAgd2luZG93LkRCTVMgPSBuZXcgTG9jYWxEQk1TKCk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5EQk1TID0gbWFrZUxvY2FsREJNU1dyYXBwZXIod2luZG93LkRCTVMpO1xyXG4vLyAgICAgICAgICAgIERCTVMuc2V0RGF0YWJhc2UoRGVtb0Jhc2UuZGF0YSwgb25CYXNlTG9hZGVkKTtcclxuICAgICAgICAgICAgcnVuQmFzZVNlbGVjdERpYWxvZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoTU9ERSA9PT0gJ05JTVNfU2VydmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBSZW1vdGVEQk1TID0gbWFrZVJlbW90ZURCTVMoTG9jYWxEQk1TKTtcclxuICAgICAgICAgICAgd2luZG93LkRCTVMgPSBuZXcgUmVtb3RlREJNUygpO1xyXG4gICAgICAgICAgICBjb25zaXN0ZW5jeUNoZWNrKChjaGVja1Jlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc2lzdGVuY3lDaGVja0FsZXJ0KGNoZWNrUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIG9uRGF0YWJhc2VMb2FkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHJ1bkJhc2VTZWxlY3REaWFsb2coKSB7XHJcbiAgICAgICAgY29uc3QgZGJEaWFsb2cgPSBxdWVyeUVsKCcuc2V0LWRhdGFiYXNlLWRpYWxvZycpO1xyXG4gICAgICAgIGFkZEVsKHF1ZXJ5RWwoJ2JvZHknKSwgZGJEaWFsb2cpO1xyXG4gICAgICAgIGxpc3RlbihxZWUoZGJEaWFsb2csICcub24tYWN0aW9uLWJ1dHRvbicpLCAnY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgJChkYkRpYWxvZykubW9kYWwoJ2hpZGUnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZWFkTG9jYWxCYXNlcygpLnRoZW4oKGJyb3dzZXJCYXNlcykgPT4ge1xyXG4gICAgICAgICAgICBhZGRFbHMocWVlKGRiRGlhbG9nLCAnLm1vZGFsLWJvZHkgLmJhY2t1cC1iYXNlcycpLCAoYnJvd3NlckJhc2VzIHx8IFtdKS5tYXAoKGJhc2UsaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVNlbGVjdCA9IHFtdGUoJy5iYWNrdXAtYmFzZS10bXBsJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IHFlZShiYXNlU2VsZWN0LCAnaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgIHNldEF0dHIoaW5wdXQsICd2YWx1ZScsIFwiYnJvd3NlckJhY2t1cFwiICsgaSk7IFxyXG4gICAgICAgICAgICAgICAgc2V0QXR0cihpbnB1dCwgJ2lkJywgXCJkYlNvdXJjZUJyb3dzZXJCYWNrdXBcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuYmFzZSA9IGJhc2U7XHJcbiAgICAgICAgICAgICAgICBzZXRBdHRyKHFlZShiYXNlU2VsZWN0LCAnbGFiZWwnKSwgJ2ZvcicsIFwiZGJTb3VyY2VCcm93c2VyQmFja3VwXCIgKyBpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShiYXNlLk1ldGEuc2F2ZVRpbWUpLmZvcm1hdCgnZGQgbW1tIHl5eXkgSEg6TU06c3MnKTtcclxuICAgICAgICAgICAgICAgIGFkZEVsKHFlZShiYXNlU2VsZWN0LCAnLmJhc2UtbmFtZScpLCBtYWtlVGV4dChiYXNlLk1ldGEubmFtZSArICcgKCcgKyBkYXRlICsgJyknKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVNlbGVjdDtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcWVlKGRiRGlhbG9nLCAnaW5wdXRbbmFtZT1kYlNvdXJjZV0nKS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcWVlKGRiRGlhbG9nLCAnI2RiU291cmNlRGVtb0Jhc2UnKS5iYXNlID0gQ29tbW9uVXRpbHMuY2xvbmUoRGVtb0Jhc2UuZGF0YSk7XHJcbiAgICAgICAgICAgIHFlZShkYkRpYWxvZywgJyNkYlNvdXJjZUVtcHR5QmFzZScpLmJhc2UgPSBDb21tb25VdGlscy5jbG9uZShFbXB0eUJhc2UuZGF0YSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBhZGRFbChxZWUoZGJEaWFsb2csICcuZGVtby1iYXNlLW5hbWUnKSwgbWFrZVRleHQoRGVtb0Jhc2UuZGF0YS5NZXRhLm5hbWUpKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGRpYWxvZ09uQmFzZUxvYWQgPSBlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikgeyBVdGlscy5oYW5kbGVFcnJvcihlcnIpOyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgICQoZGJEaWFsb2cpLm1vZGFsKCdoaWRlJyk7XHJcbiAgICAgICAgICAgICAgICBvbkJhc2VMb2FkZWQoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaW5pdEJhc2VMb2FkQnRuKHFlZShkYkRpYWxvZywgJy51cGxvYWQtZGInKSwgcWVlKGRiRGlhbG9nLCAnLnVwbG9hZC1kYiBpbnB1dCcpLCBkaWFsb2dPbkJhc2VMb2FkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxpc3RlbihxZWUoZGJEaWFsb2csICcub24tYWN0aW9uLWJ1dHRvbicpLCAnY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gZ2V0U2VsZWN0ZWRSYWRpbyhkYkRpYWxvZywgJ2lucHV0W25hbWU9ZGJTb3VyY2VdJykuYmFzZTtcclxuICAgICAgICAgICAgICAgIERCTVMuc2V0RGF0YWJhc2UoYmFzZSwgZGlhbG9nT25CYXNlTG9hZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgTDEwbi5sb2NhbGl6ZVN0YXRpYyhkYkRpYWxvZyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAkKGRiRGlhbG9nKS5tb2RhbCh7XHJcbiAgICAgICAgICAgICAgICBiYWNrZHJvcDogJ3N0YXRpYydcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29uc2lzdGVuY3lDaGVja0FsZXJ0KGNoZWNrUmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKGNoZWNrUmVzdWx0LmVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIFV0aWxzLmFsZXJ0KGdldEwxMG4oJ292ZXJ2aWV3LWNvbnNpc3RlbmN5LXByb2JsZW0tZGV0ZWN0ZWQnKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbnNpc3RlbmN5IGNoZWNrIGRpZG5cXCd0IGZpbmQgZXJyb3JzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnNpc3RlbmN5Q2hlY2soY2FsbGJhY2spIHtcclxuICAgICAgICBEQk1TLmdldENvbnNpc3RlbmN5Q2hlY2tSZXN1bHQoKGVyciwgY2hlY2tSZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikgeyBVdGlscy5oYW5kbGVFcnJvcihlcnIpOyByZXR1cm47IH1cclxuICAgICAgICAgICAgY2hlY2tSZXN1bHQuZXJyb3JzLmZvckVhY2goQ29tbW9uVXRpbHMuY29uc29sZUVycik7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGNoZWNrUmVzdWx0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XHJcbiAgICAgICAgc3RhdGUubmF2aWdhdGlvbiA9IGdldEVsKCduYXZpZ2F0aW9uJyk7XHJcbiAgICAgICAgc3RhdGUuY29udGFpbmVycyA9IHtcclxuICAgICAgICAgICAgcm9vdDogc3RhdGUsXHJcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGdldEVsKCdjb250ZW50QXJlYScpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRhdGFiYXNlTG9hZCgpIHtcclxuICAgICAgICBQZXJtaXNzaW9uSW5mb3JtZXIucmVmcmVzaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyKTsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgICAgICBQZXJtaXNzaW9uSW5mb3JtZXIuaXNBZG1pbigoZXJyMiwgaXNBZG1pbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycjIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyMik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAkLmRhdGV0aW1lcGlja2VyLnNldERhdGVGb3JtYXR0ZXIoJ21vbWVudCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBidXR0b247XHJcbiAgICAgICAgICAgICAgICBzdGF0ZUluaXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJzID0ge307XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFRhYiA9ICdPdmVydmlldyc7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkVmlldyA9IChjb250YWluZXJzLCBidG5OYW1lLCB2aWV3TmFtZSwgb3B0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhYnNbdmlld05hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1JlczogVXRpbHMuYWRkVmlldyhjb250YWluZXJzLCBidG5OYW1lLCB3aW5kb3dbdmlld05hbWVdLCBvcHRzKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ292ZXJ2aWV3JywgJ092ZXJ2aWV3Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBhZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICdwcm9maWxlcycsICdQcm9maWxlcycpO1xyXG4gICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnY2hhcmFjdGVycycsICdDaGFyYWN0ZXJzJyk7XHJcbiAgICAgICAgICAgICAgICBhZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICdwbGF5ZXJzJywgJ1BsYXllcnMnKTtcclxuICAgICAgICAgICAgICAgIGFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ3N0b3JpZXMnLCAnU3RvcmllcycpO1xyXG4gICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnYWRhcHRhdGlvbnMnLCAnQWRhcHRhdGlvbnMnKTtcclxuICAgICAgICAgICAgICAgIGFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ2JyaWVmaW5ncycsICdCcmllZmluZ3MnKTtcclxuICAgICAgICAgICAgICAgIGFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ3JlbGF0aW9ucycsICdSZWxhdGlvbnMnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBhZGRDbGFzcyhtYWtlRWwoJ2RpdicpLCAnbmF2LXNlcGFyYXRvcicpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICd0aW1lbGluZScsICdUaW1lbGluZScsIHsgY2xheno6ICd0aW1lbGluZUJ1dHRvbiBpY29uLWJ1dHRvbicsIHRvb2x0aXA6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBhZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICdzb2NpYWwtbmV0d29yaycsICdTb2NpYWxOZXR3b3JrJywgeyBjbGF6ejogJ3NvY2lhbE5ldHdvcmtCdXR0b24gaWNvbi1idXR0b24nLCB0b29sdGlwOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAncHJvZmlsZS1maWx0ZXInLCAnUHJvZmlsZUZpbHRlcicsIHsgY2xheno6ICdmaWx0ZXJCdXR0b24gaWNvbi1idXR0b24nLCB0b29sdGlwOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnZ3JvdXBzJywgJ0dyb3VwUHJvZmlsZScsIHsgY2xheno6ICdncm91cHNCdXR0b24gaWNvbi1idXR0b24nLCB0b29sdGlwOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAndGV4dFNlYXJjaCcsICdUZXh0U2VhcmNoJywgeyBjbGF6ejogJ3RleHRTZWFyY2hCdXR0b24gaWNvbi1idXR0b24nLCB0b29sdGlwOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAncm9sZUdyaWQnLCAnUm9sZUdyaWQnLCB7IGNsYXp6OiAncm9sZUdyaWRCdXR0b24gaWNvbi1idXR0b24nLCB0b29sdGlwOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIGFkZENsYXNzKG1ha2VFbCgnZGl2JyksICduYXYtc2VwYXJhdG9yJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChNT0RFID09PSAnTklNU19TZXJ2ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnYWRtaW5zJywgJ0FjY2Vzc01hbmFnZXInLCB7IGNsYXp6OiAnYWNjZXNzTWFuYWdlckJ1dHRvbiBpY29uLWJ1dHRvbicsIHRvb2x0aXA6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICdsb2dWaWV3ZXInLCAnTG9nVmlld2VyMicsIHsgY2xheno6ICdsb2dWaWV3ZXJCdXR0b24gaWNvbi1idXR0b24nLCB0b29sdGlwOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIGFkZENsYXNzKG1ha2VFbCgnZGl2JyksICduYXYtc2VwYXJhdG9yJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0FkbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gbWFrZUJ1dHRvbignZGF0YUxvYWRCdXR0b24gaWNvbi1idXR0b24nLCAnb3Blbi1kYXRhYmFzZScsIG51bGwsIGJ0bk9wdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gbWFrZUVsKCdpbnB1dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgPSAnZmlsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoaW5wdXQsICdoaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyKGlucHV0LCAndGFiaW5kZXgnLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpbml0QmFzZUxvYWRCdG4oYnV0dG9uLCBpbnB1dCwgb25CYXNlTG9hZGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBidXR0b24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ2RhdGFTYXZlQnV0dG9uIGljb24tYnV0dG9uJywgJ3NhdmUtZGF0YWJhc2UnLCBGaWxlVXRpbHMuc2F2ZUZpbGUsIGJ0bk9wdHMpKTtcclxuICAgICAgICAgICAgICAgIGlmIChNT0RFID09PSAnU3RhbmRhbG9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBtYWtlQnV0dG9uKCduZXdCYXNlQnV0dG9uIGljb24tYnV0dG9uJywgJ2NyZWF0ZS1kYXRhYmFzZScsIEZpbGVVdGlscy5tYWtlTmV3QmFzZShvbkJhc2VMb2FkZWQpLCBidG5PcHRzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ21haW5IZWxwQnV0dG9uIGljb24tYnV0dG9uJywgJ2RvY3MnLCBGaWxlVXRpbHMub3BlbkhlbHAsIGJ0bk9wdHMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBtYWtlTDEwbkJ1dHRvbigpKTtcclxuXHJcbi8vICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ3Rlc3RCdXR0b24gaWNvbi1idXR0b24nLCAndGVzdCcsIFRlc3RVdGlscy5ydW5UZXN0cywgYnRuT3B0cykpO1xyXG4vLyAgICAgICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBtYWtlQnV0dG9uKCdjaGVja0NvbnNpc3RlbmN5QnV0dG9uIGljb24tYnV0dG9uJywgJ2NoZWNrQ29uc2lzdGVuY3knLCBjaGVja0NvbnNpc3RlbmN5LCBidG5PcHRzKSk7XHJcbi8vICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ2NoZWNrQ29uc2lzdGVuY3lCdXR0b24gaWNvbi1idXR0b24nLCAnc2hvd0RibXNDb25zaXN0ZW5jeVN0YXRlJywgc2hvd0RibXNDb25zaXN0ZW5jeVN0YXRlLCBidG5PcHRzKSk7XHJcbi8vICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ2NsaWNrQWxsVGFic0J1dHRvbiBpY29uLWJ1dHRvbicsICdjbGlja0FsbFRhYnMnLCBUZXN0VXRpbHMuY2xpY2tUaHJvdWdodEhlYWRlcnMsIGJ0bk9wdHMpKTtcclxuLy8gICAgICAgICAgICAgICAgYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgbWFrZUJ1dHRvbignY2xpY2tBbGxUYWJzQnV0dG9uIGljb24tYnV0dG9uJywgJ3Nob3dEaWZmJywgVGVzdFV0aWxzLnNob3dEaWZmRXhhbXBsZSwgYnRuT3B0cykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1PREUgPT09ICdOSU1TX1NlcnZlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBtYWtlQnV0dG9uKCdsb2dvdXRCdXR0b24gaWNvbi1idXR0b24nLCAnbG9nb3V0JywgcG9zdExvZ291dCwgYnRuT3B0cykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgbWFrZUJ1dHRvbigncmVmcmVzaEJ1dHRvbiBpY29uLWJ1dHRvbicsICdyZWZyZXNoJywgKCkgPT4gc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpLCBidG5PcHRzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgVXRpbHMuc2V0Rmlyc3RUYWIoc3RhdGUuY29udGFpbmVycywgdGFic1tmaXJzdFRhYl0udmlld1Jlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1PREUgPT09ICdTdGFuZGFsb25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZEJlZm9yZVVubG9hZExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBdXRvU2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICBGaWxlVXRpbHMubWFrZU5ld0Jhc2UoKTtcclxuLy8gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1blRlc3RzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBvbkJhc2VMb2FkZWQoZXJyMykge1xyXG4gICAgICAgIGlmIChlcnIzKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycjMpOyByZXR1cm47IH1cclxuICAgICAgICBjb25zaXN0ZW5jeUNoZWNrKChjaGVja1Jlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zaXN0ZW5jeUNoZWNrQWxlcnQoY2hlY2tSZXN1bHQpO1xyXG4gICAgICAgICAgICBpZihzdGF0ZS5maXJzdEJhc2VMb2FkKXtcclxuICAgICAgICAgICAgICAgIG9uRGF0YWJhc2VMb2FkKCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5maXJzdEJhc2VMb2FkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Vmlldy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaW5pdEJhc2VMb2FkQnRuKGJ1dHRvbiwgaW5wdXQsIG9uQmFzZUxvYWRlZCkge1xyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBGaWxlVXRpbHMucmVhZFNpbmdsZUZpbGUob25CYXNlTG9hZGVkKSwgZmFsc2UpO1xyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIGlucHV0LmNsaWNrKCk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgbmF2aWdhdGlvbiB0byBcIiNcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VMMTBuQnV0dG9uKCkge1xyXG4gICAgICAgIGNvbnN0IGwxMG5CdG4gPSBtYWtlQnV0dG9uKCd0b2dnbGVMMTBuQnV0dG9uJywgJ2wxMG4nLCBMMTBuLnRvZ2dsZUwxMG4sIGJ0bk9wdHMpO1xyXG4gICAgICAgIGNvbnN0IHNldEljb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGwxMG5CdG4uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3RyRm9ybWF0KCd1cmwoXCIuL2ltYWdlcy97MH0uc3ZnXCIpJywgW2dldEwxMG4oJ2hlYWRlci1kaWN0aW9uYXJ5LWljb24nKV0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTDEwbi5vbkwxMG5DaGFuZ2Uoc2V0SWNvbik7XHJcbiAgICAgICAgc2V0SWNvbigpO1xyXG4gICAgICAgIHJldHVybiBsMTBuQnRuO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNob3dEYm1zQ29uc2lzdGVuY3lTdGF0ZSgpIHtcclxuICAgICAgICBjb25zaXN0ZW5jeUNoZWNrKGNoZWNrUmVzID0+IFRlc3RVdGlscy5zaG93TW9kdWxlU2NoZW1hKGNoZWNrUmVzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb25zaXN0ZW5jeSgpIHtcclxuICAgICAgICBjb25zaXN0ZW5jeUNoZWNrKGNoZWNrUmVzID0+IFRlc3RVdGlscy5zaG93Q29uc2lzdGVuY3lDaGVja0FsZXJ0KGNoZWNrUmVzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcG9zdExvZ291dCgpIHtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbG9nb3V0Rm9ybSBidXR0b24nKS5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VCdXR0b24oY2xhenosIG5hbWUsIGNhbGxiYWNrLCBvcHRzKSB7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uID0gbWFrZUVsKCdidXR0b24nKTtcclxuICAgICAgICBhZGRDbGFzcyhidXR0b24sIGNsYXp6KTtcclxuICAgICAgICBpZiAob3B0cy50b29sdGlwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGVnYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgJChidXR0b24pLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCBMMTBuLmdldFZhbHVlKGBoZWFkZXItJHtuYW1lfWApKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTDEwbi5vbkwxMG5DaGFuZ2UoZGVsZWdhdGUpO1xyXG4gICAgICAgICAgICAkKGJ1dHRvbikudG9vbHRpcCh7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogTDEwbi5nZXRWYWx1ZShgaGVhZGVyLSR7bmFtZX1gKSxcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZENsYXNzKGJ1dHRvbiwgJ2FjdGlvbi1idXR0b24nKTtcclxuICAgICAgICBpZiAob3B0cy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgYWRkQ2xhc3MoYnV0dG9uLCBvcHRzLmNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBsaXN0ZW4oYnV0dG9uLCAnY2xpY2snLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBidXR0b247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQmVmb3JlVW5sb2FkTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBtYWtlQmFja3VwKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRMMTBuKCd1dGlscy1jbG9zZS1wYWdlLXdhcm5pbmcnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBldnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBldnQgPSB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnJldHVyblZhbHVlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiByZWFkTG9jYWxCYXNlcygpIHtcclxuICAgICAgICBpZiAoIXdpbmRvdy5pbmRleGVkREIpIHtcclxuICAgICAgICAgICAgVXRpbHMuYWxlcnQoTDEwbi5nZXQoJ2Vycm9ycycsICdpbmRleGVkZGItaXMtbm90LWZvdW5kJykpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gW107XHJcbiAgICAgICAgd2hpbGUoIVIuY29udGFpbnMoY291bnRlciwgY291bnRlcnMpKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJzLnB1c2goY291bnRlcik7XHJcbiAgICAgICAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgQkFDS1VQX05VTUJFUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNvdW50ZXJzLm1hcChjb3VudGVyID0+IExvY2FsQmFzZUFQSS5nZXQoJ2Jhc2UnICsgY291bnRlcikpKS50aGVuKGJhc2VzID0+IHtcclxuICAgICAgICAgICAgYmFzZXMgPSBiYXNlcy5maWx0ZXIoYmFzZSA9PiAhUi5pc05pbChiYXNlKSk7XHJcbiAgICAgICAgICAgIGlmKGJhc2VzLmxlbmd0aCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYmFzZXMuc29ydChDb21tb25VdGlscy5jaGFyT3JkQUZhY3RvcnkoIGJhc2UgPT4gLW5ldyBEYXRlKGJhc2Uub2JqLk1ldGEuc2F2ZVRpbWUpLmdldFRpbWUoKSkpXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlcy5tYXAoUi5wcm9wKCdvYmonKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGxvY2FsQXV0b1NhdmUoKSB7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cuaW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbWFrZUJhY2t1cCgpO1xyXG4gICAgICAgIHNldEludGVydmFsKG1ha2VCYWNrdXAsIEJBQ0tVUF9JTlRFUlZBTCk7IC8vIDUgbWluXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxldCBjb3VudGVyID0gMDtcclxuICAgIGZ1bmN0aW9uIG1ha2VCYWNrdXAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coY291bnRlciArIDEpO1xyXG4gICAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgQkFDS1VQX05VTUJFUjtcclxuICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgYXV0b3NhdmUnKTtcclxuICAgICAgICBcclxuICAgICAgICBEQk1TLmdldERhdGFiYXNlKChlcnIsIGRhdGFiYXNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBMb2NhbEJhc2VBUEkucHV0KCdiYXNlJyArIGNvdW50ZXIsIGRhdGFiYXNlKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdXRvc2F2ZSBPSyAnICsgbmV3IERhdGUoKSk7XHJcbi8vICAgICAgICAgICAgICAgIExvY2FsQmFzZUFQSS5nZXQoJ2Jhc2UnICsgY291bnRlcikudGhlbigoZGF0YWJhc2UpID0+IHtcclxuLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFiYXNlKTtcclxuLy8gICAgICAgICAgICAgICAgfSkuY2F0Y2goVXRpbHMuaGFuZGxlRXJyb3IpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChVdGlscy5oYW5kbGVFcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxufSkodGhpcy5QYWdlTWFuYWdlciA9IHt9KTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNSBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbi8qZ2xvYmFsXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuKChleHBvcnRzLCBtb2RlKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHt9O1xyXG5cclxuICAgIHN0YXRlLnN1bW1hcnkgPSB7fTtcclxuXHJcbiAgICBpZiAobW9kZSA9PT0gJ05JTVNfU2VydmVyJyAmJiBQRVJNSVNTSU9OX0lORk9STUVSX0VOQUJMRUQpIHtcclxuICAgICAgICBleHBvcnRzLnJlZnJlc2ggPSAoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgICAgICB1cmw6ICcvZ2V0UGVybWlzc2lvbnNTdW1tYXJ5JyxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnLFxyXG4gICAgICAgICAgICAgICAgdGltZW91dDogQ29uc3RhbnRzLmh0dHBUaW1lb3V0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmVxdWVzdC5kb25lKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdW1tYXJ5ID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgYWxlcnQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgYWxlcnQoc3RhdGUuc3VtbWFyeSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmVxdWVzdC5mYWlsKChlcnJvckluZm8sIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvckluZm8ucmVzcG9uc2VUZXh0IHx8ICdlcnJvcicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGV4cG9ydHMuc3Vic2NyaWJlLCA1MDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBleHBvcnRzLnN1YnNjcmliZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgICAgICB1cmw6ICcvc3Vic2NyaWJlT25QZXJtaXNzaW9uc1VwZGF0ZScsXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IENvbnN0YW50cy5odHRwVGltZW91dFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlcXVlc3QuZG9uZSgoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuc3VtbWFyeSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgYWxlcnQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgYWxlcnQoc3RhdGUuc3VtbWFyeSk7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlcXVlc3QuZmFpbCgoZXJyb3JJbmZvLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChleHBvcnRzLnN1YnNjcmliZSwgNTAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWZyZXNoKCk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNBZG1pbiA9IChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0ZS5zdW1tYXJ5LmlzQWRtaW4pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNFZGl0b3IgPSAoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdGUuc3VtbWFyeS5pc0VkaXRvcik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNPYmplY3RFZGl0YWJsZVN5bmMgPSAodHlwZSwgbmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuc3VtbWFyeS5pc0VkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlLnN1bW1hcnkuZXhpc3RFZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuc3VtbWFyeS51c2VyW3R5cGVdLmluZGV4T2YobmFtZSkgIT09IC0xO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNFbnRpdHlFZGl0YWJsZSA9ICh0eXBlLCBlbnRpdHlOYW1lLCBjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBpc09iamVjdEVkaXRhYmxlU3luYyh0eXBlLCBlbnRpdHlOYW1lKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5nZXRFbnRpdHlOYW1lc0FycmF5ID0gUi5jdXJyeSgodHlwZSwgZWRpdGFibGVPbmx5LCBjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyRW50aXRpZXMgPSBzdGF0ZS5zdW1tYXJ5LnVzZXJbdHlwZV07XHJcbiAgICAgICAgICAgIGNvbnN0IGFsbEVudGl0aWVzID0gc3RhdGUuc3VtbWFyeS5hbGxbdHlwZV07XHJcbiAgICAgICAgICAgIGNvbnN0IG93bmVyTWFwID0gc3RhdGUuc3VtbWFyeS5vd25lck1hcHNbdHlwZV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gYWxsRW50aXRpZXMuZmlsdGVyKChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRpdGFibGVPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0RWRpdGFibGVTeW5jKHR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pLm1hcChuYW1lID0+ICh7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogYCR7b3duZXJNYXBbbmFtZV19LiAke25hbWV9YCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IGlzT2JqZWN0RWRpdGFibGVTeW5jKHR5cGUsIG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgaXNPd25lcjogdXNlckVudGl0aWVzLmluZGV4T2YobmFtZSkgIT09IC0xLFxyXG4gICAgICAgICAgICAgICAgaGFzT3duZXI6IG93bmVyTWFwW25hbWVdICE9PSAnLSdcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmFtZTJzdHIgPSBhID0+IGEuZGlzcGxheU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eUNtcCA9IENvbW1vblV0aWxzLmNoYXJPcmRBRmFjdG9yeUJhc2UoJ2FzYycsIChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5pc093bmVyICYmIGIuaXNPd25lcikgcmV0dXJuIG5hbWUyc3RyKGEpID4gbmFtZTJzdHIoYik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5pc093bmVyKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5pc093bmVyKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYS5oYXNPd25lciAmJiBiLmhhc093bmVyKSByZXR1cm4gbmFtZTJzdHIoYSkgPiBuYW1lMnN0cihiKTtcclxuICAgICAgICAgICAgICAgIGlmIChhLmhhc093bmVyKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5oYXNPd25lcikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUyc3RyKGEpID4gbmFtZTJzdHIoYik7XHJcbiAgICAgICAgICAgIH0sIFIuaWRlbnRpdHkpO1xyXG5cclxuICAgICAgICAgICAgLy8gICAgICAgICAgICBuYW1lcy5zb3J0KFV0aWxzLmNoYXJPcmRBT2JqZWN0KTtcclxuICAgICAgICAgICAgbmFtZXMuc29ydChlbnRpdHlDbXApO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmFtZXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBleHBvcnRzLmFyZUFkYXB0YXRpb25zRWRpdGFibGUgPSAoYWRhcHRhdGlvbnMsIGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCB7IGlzQWRhcHRhdGlvblJpZ2h0c0J5U3RvcnkgfSA9IHN0YXRlLnN1bW1hcnk7XHJcblxyXG4gICAgICAgICAgICBhZGFwdGF0aW9ucy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtlbGVtLnN0b3J5TmFtZX0tJHtlbGVtLmNoYXJhY3Rlck5hbWV9YDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0FkYXB0YXRpb25SaWdodHNCeVN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwW2tleV0gPSBpc09iamVjdEVkaXRhYmxlU3luYygnc3RvcnknLCBlbGVtLnN0b3J5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcFtrZXldID0gaXNPYmplY3RFZGl0YWJsZVN5bmMoJ2NoYXJhY3RlcicsIGVsZW0uY2hhcmFjdGVyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWFwKTtcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnU3RhbmRhbG9uZScpIHtcclxuICAgICAgICBleHBvcnRzLnJlZnJlc2ggPSAoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzQWRtaW4gPSAoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5pc0VkaXRvciA9IChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBleHBvcnRzLmdldEVudGl0eU5hbWVzQXJyYXkgPSBSLmN1cnJ5KCh0eXBlLCBlZGl0YWJsZU9ubHksIGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NOYW1lcyhlcnIsIG5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdOYW1lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBuZXdOYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgREJNUy5nZXRFbnRpdHlOYW1lc0FycmF5KHR5cGUsIHByb2Nlc3NOYW1lcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNFbnRpdHlFZGl0YWJsZSA9ICh0eXBlLCBlbnRpdHlOYW1lLCBjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBleHBvcnRzLmFyZUFkYXB0YXRpb25zRWRpdGFibGUgPSAoYWRhcHRhdGlvbnMsIGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgICAgICAgICBhZGFwdGF0aW9ucy5mb3JFYWNoKChlbGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtYXBbYCR7ZWxlbS5zdG9yeU5hbWV9LSR7ZWxlbS5jaGFyYWN0ZXJOYW1lfWBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXApO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn0pKHRoaXMuUGVybWlzc2lvbkluZm9ybWVyID0ge30sIE1PREUpO1xyXG4iXX0=
